/*
-------------------------------------------------- -----------------------------------------
The frame content is protected by copyright law. In order to facilitate individual learning,
allows to download the program source information, but does not allow individuals or a third
party for profit, the commercial use of the source information. Without consent,
does not allow any form (even if partial, or modified) database storage,
copy the source of information. If the source content provided by third parties,
which corresponds to the third party content is also protected by copyright.

If you are found to have infringed copyright behavior, please give me a hint. THX!

Here in particular it emphasized that the third party is not allowed to contact addresses
published in this "version copyright statement" to send advertising material.
I will take legal means to resist sending spam.
-------------------------------------------------- ----------------------------------------
The framework under the GNU agreement, Detail View GNU License.
If you think about this item affection join the development team,
Please contact me: LaurentLeeJS@gmail.com
-------------------------------------------------- ----------------------------------------
Laurent.Lee.Framework Coded by Laurent Lee
*/

///本文件由程序自动生成,请不要自行修改
using System;
using Laurent.Lee.CLB;
#pragma warning disable

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        public unsafe static void Reverse(long[] array, int index, int length)
        {
            fixed (long* valueFixed = array)
            {
                for (long* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    long value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static long[] reverse(this long[] array)
        {
            if (array == null || array.Length == 0) return TmphNullValue<long>.Array;
            Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        public unsafe static long[] GetReverse(long[] array, int index, int length)
        {
            long[] newValues = new long[length];
            fixed (long* valueFixed = array, newValueFixed = newValues)
            {
                for (long* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end;
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static long[] getReverse(this long[] array)
        {
            if (array == null || array.Length == 0) return TmphNullValue<long>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        public unsafe static long* IndexOf
            (long* valueFixed, int length, long value)
        {
            for (long* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this long[] array, long value)
        {
            if (array != null)
            {
                fixed (long* valueFixed = array)
                {
                    long* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        public unsafe static long* IndexOf
            (long* valueFixed, int length, Func<long, bool> isValue)
        {
            for (long* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this long[] array, Func<long, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (long* valueFixed = array)
                {
                    long* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(long)</returns>
        public unsafe static long firstOrDefault
            (this long[] array, Func<long, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (long* valueFixed = array)
                {
                    long* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(long);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this long[] array, Func<long, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int value = 0;
                fixed (long* valueFixed = array)
                {
                    for (long* end = valueFixed + array.Length; end != valueFixed; )
                    {
                        if (isValue(*--end)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static long[] replaceFirst
            (this long[] array, long value, Func<long, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (long* valueFixed = array)
                {
                    long* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return TmphNullValue<long>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static long[] getArray<TValueType>
            (this TValueType[] array, Func<TValueType, long> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                long[] newValues = new long[array.Length];
                fixed (long* newValueFixed = newValues)
                {
                    long* writeValue = newValueFixed;
                    foreach (TValueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return TmphNullValue<long>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<long> GetFind
            (this long[] array, int index, int length, Func<long, bool> isValue)
        {
            long[] newValues = new long[length < sizeof(int) ? sizeof(int) : length];
            fixed (long* newValueFixed = newValues, valueFixed = array)
            {
                long* write = newValueFixed;
                for (long* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return TmphSubArray<long>.Unsafe(newValues, 0, (int)(write - newValueFixed));
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<long> getFind
            (this long[] array, Func<long, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                return GetFind(array, 0, array.Length, isValue);
            }
            return default(TmphSubArray<long>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static long[] getFindArray
            (this long[] array, Func<long, bool> isValue)
        {
            if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                TmphMemoryPool pool = Laurent.Lee.CLB.TmphMemoryPool.GetDefaultPool(length = ((length + 31) >> 5) << 2);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return GetFindArray(array, 0, array.Length, isValue, new TmphFixedMap(dataFixed));
                    }
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<long>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        public unsafe static long[] GetFindArray
            (long[] array, int index, int count, Func<long, bool> isValue, TmphFixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (long* valueFixed = array)
            {
                long* startFixed = valueFixed + index, end = startFixed + count;
                for (long* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    long[] newValues = new long[length];
                    fixed (long* newValueFixed = newValues)
                    {
                        long* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return TmphNullValue<long>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this long[] array, out long value)
        {
            if (array.length() != 0)
            {
                fixed (long* valueFixed = array)
                {
                    value = *valueFixed;
                    for (long* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static long max(this long[] array, long TmphNullValue)
        {
            long value;
            return max(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this TValueType[] array, Func<TValueType, long> getKey, out long value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (TValueType nextValue in array)
                {
                    long nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static long maxKey<TValueType>
            (this TValueType[] array, Func<TValueType, long> getKey, long TmphNullValue)
        {
            long value;
            return maxKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this TValueType[] array, Func<TValueType, long> getKey, out TValueType value)
        {
            if (array.length() != 0)
            {
                long maxKey = getKey(value = array[0]);
                foreach (TValueType nextValue in array)
                {
                    long nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>(this TValueType[] array, Func<TValueType, long> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return max(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this long[] array, out long value)
        {
            if (array.length() != 0)
            {
                fixed (long* valueFixed = array)
                {
                    value = *valueFixed;
                    for (long* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = long.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static long min(this long[] array, long TmphNullValue)
        {
            long value;
            return min(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this TValueType[] array, Func<TValueType, long> getKey, out long value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (TValueType nextValue in array)
                {
                    long nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = long.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static long minKey<TValueType>
            (this TValueType[] array, Func<TValueType, long> getKey, long TmphNullValue)
        {
            long value;
            return minKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>(this TValueType[] array, Func<TValueType, long> getKey, out TValueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                long minKey = getKey(value);
                foreach (TValueType nextValue in array)
                {
                    long nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>(this TValueType[] array, Func<TValueType, long> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return min(array, getKey, out value) ? value : TmphNullValue;
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static long[] getReverse(this TmphSubArray<long> array)
        {
            if (array.Count == 0) return TmphNullValue<long>.Array;
            return TmphArrayExtension.GetReverse(array.Array, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static TmphSubArray<long> reverse(this TmphSubArray<long> array)
        {
            if (array.Count > 1) TmphArrayExtension.Reverse(array.Array, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this TmphSubArray<long> array, long value)
        {
            if (array.Count != 0)
            {
                fixed (long* valueFixed = array.Array)
                {
                    long* start = valueFixed + array.StartIndex, index = TmphArrayExtension.IndexOf(start, array.Count, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this TmphSubArray<long> array, Func<long, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (long* valueFixed = array.Array)
                {
                    long* start = valueFixed + array.StartIndex, index = TmphArrayExtension.IndexOf(start, array.Count, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(long)</returns>
        public unsafe static long firstOrDefault
            (this TmphSubArray<long> array, Func<long, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Count)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (long* valueFixed = array.Array)
                {
                    long* valueIndex = TmphArrayExtension.IndexOf(valueFixed + array.StartIndex + index, array.Count - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(long);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count(this TmphSubArray<long> array, Func<long, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int value = 0;
                fixed (long* valueFixed = array.Array)
                {
                    long* start = valueFixed + array.StartIndex, end = start + array.Count;
                    do
                    {
                        if (isValue(*start)) ++value;
                    }
                    while (++start != end);
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static TmphSubArray<long> replaceFirst
            (this TmphSubArray<long> array, long value, Func<long, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (long* valueFixed = array.Array)
                {
                    long* valueIndex = TmphArrayExtension.IndexOf(valueFixed + array.StartIndex, array.Count, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<long> find
            (this TmphSubArray<long> array, Func<long, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (long* valueFixed = array.Array)
                {
                    long* write = valueFixed + array.StartIndex, start = write, end = write + array.Count;
                    do
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    while (++start != end);
                    return TmphSubArray<long>.Unsafe(array.Array, array.StartIndex, (int)(write - valueFixed) - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<long> getFind
            (this TmphSubArray<long> array, Func<long, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                return TmphArrayExtension.GetFind(array.Array, array.StartIndex, array.Count, isValue);
            }
            return default(TmphSubArray<long>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static long[] getFindArray
            (this TmphSubArray<long> array, Func<long, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int length = ((array.Count + 31) >> 5) << 2;
                TmphMemoryPool pool = Laurent.Lee.CLB.TmphMemoryPool.GetDefaultPool(length);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return TmphArrayExtension.GetFindArray(array.Array, array.StartIndex, array.Count, isValue, new TmphFixedMap(dataFixed));
                    }
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<long>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static long[] getArray<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, long> getValue)
        {
            if (TmphSubArray.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] array = TmphSubArray.Array;
                long[] newValues = new long[TmphSubArray.Count];
                fixed (long* newValueFixed = newValues)
                {
                    long* write = newValueFixed;
                    int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                    do
                    {
                        *write++ = getValue(array[index++]);
                    }
                    while (index != endIndex);
                }
                return newValues;
            }
            return TmphNullValue<long>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static TValueType[] getArray<TValueType>
            (this TmphSubArray<long> array, Func<long, TValueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] newValues = new TValueType[array.Count];
                fixed (long* arrayFixed = array.Array)
                {
                    long* start = arrayFixed + array.StartIndex, end = start + array.Count;
                    int index = 0;
                    do
                    {
                        newValues[index++] = getValue(*start);
                    }
                    while (++start != end);
                }
                return newValues;
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static TmphSubArray<long> each
            (this TmphSubArray<long> array, Action<long> method)
        {
            if (array.Count != 0)
            {
                if (method == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (long* valueFixed = array.Array)
                {
                    for (long* start = valueFixed + array.StartIndex, end = start + array.Count; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this TmphSubArray<long> array, out long value)
        {
            if (array.Count != 0)
            {
                fixed (long* valueFixed = array.Array)
                {
                    long* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static long max(this TmphSubArray<long> array, long TmphNullValue)
        {
            long value;
            return max(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, long> getKey, out long value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    long nextKey = getKey(array[index]);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static long maxKey<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, long> getKey, long TmphNullValue)
        {
            long value;
            return maxKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, long> getKey, out TValueType value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                long maxKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    TValueType nextValue = array[index];
                    long nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, long> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return max(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this TmphSubArray<long> array, out long value)
        {
            if (array.Count != 0)
            {
                fixed (long* valueFixed = array.Array)
                {
                    long* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static long min(this TmphSubArray<long> array, long TmphNullValue)
        {
            long value;
            return min(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, long> getKey, out long value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    long nextKey = getKey(array[index]);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static long minKey<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, long> getKey, long TmphNullValue)
        {
            long value;
            return minKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, long> getKey, out TValueType value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                long minKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    TValueType nextValue = array[index];
                    long nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, long> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return min(array, getKey, out value) ? value : TmphNullValue;
        }
    }
}

namespace Laurent.Lee.CLB.Unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void Move(long[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (long* valueFixed = array)
                {
                    for (long* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (long* valueFixed = array) Win32.TmphKernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(long));
#endif
        }
    }
}
namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        public unsafe static void Reverse(uint[] array, int index, int length)
        {
            fixed (uint* valueFixed = array)
            {
                for (uint* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    uint value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static uint[] reverse(this uint[] array)
        {
            if (array == null || array.Length == 0) return TmphNullValue<uint>.Array;
            Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        public unsafe static uint[] GetReverse(uint[] array, int index, int length)
        {
            uint[] newValues = new uint[length];
            fixed (uint* valueFixed = array, newValueFixed = newValues)
            {
                for (uint* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end;
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static uint[] getReverse(this uint[] array)
        {
            if (array == null || array.Length == 0) return TmphNullValue<uint>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        public unsafe static uint* IndexOf
            (uint* valueFixed, int length, uint value)
        {
            for (uint* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this uint[] array, uint value)
        {
            if (array != null)
            {
                fixed (uint* valueFixed = array)
                {
                    uint* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        public unsafe static uint* IndexOf
            (uint* valueFixed, int length, Func<uint, bool> isValue)
        {
            for (uint* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this uint[] array, Func<uint, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (uint* valueFixed = array)
                {
                    uint* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(uint)</returns>
        public unsafe static uint firstOrDefault
            (this uint[] array, Func<uint, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (uint* valueFixed = array)
                {
                    uint* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(uint);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this uint[] array, Func<uint, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int value = 0;
                fixed (uint* valueFixed = array)
                {
                    for (uint* end = valueFixed + array.Length; end != valueFixed; )
                    {
                        if (isValue(*--end)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static uint[] replaceFirst
            (this uint[] array, uint value, Func<uint, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (uint* valueFixed = array)
                {
                    uint* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return TmphNullValue<uint>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static uint[] getArray<TValueType>
            (this TValueType[] array, Func<TValueType, uint> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                uint[] newValues = new uint[array.Length];
                fixed (uint* newValueFixed = newValues)
                {
                    uint* writeValue = newValueFixed;
                    foreach (TValueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return TmphNullValue<uint>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<uint> GetFind
            (this uint[] array, int index, int length, Func<uint, bool> isValue)
        {
            uint[] newValues = new uint[length < sizeof(int) ? sizeof(int) : length];
            fixed (uint* newValueFixed = newValues, valueFixed = array)
            {
                uint* write = newValueFixed;
                for (uint* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return TmphSubArray<uint>.Unsafe(newValues, 0, (int)(write - newValueFixed));
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<uint> getFind
            (this uint[] array, Func<uint, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                return GetFind(array, 0, array.Length, isValue);
            }
            return default(TmphSubArray<uint>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static uint[] getFindArray
            (this uint[] array, Func<uint, bool> isValue)
        {
            if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                TmphMemoryPool pool = Laurent.Lee.CLB.TmphMemoryPool.GetDefaultPool(length = ((length + 31) >> 5) << 2);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return GetFindArray(array, 0, array.Length, isValue, new TmphFixedMap(dataFixed));
                    }
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<uint>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        public unsafe static uint[] GetFindArray
            (uint[] array, int index, int count, Func<uint, bool> isValue, TmphFixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (uint* valueFixed = array)
            {
                uint* startFixed = valueFixed + index, end = startFixed + count;
                for (uint* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    uint[] newValues = new uint[length];
                    fixed (uint* newValueFixed = newValues)
                    {
                        uint* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return TmphNullValue<uint>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this uint[] array, out uint value)
        {
            if (array.length() != 0)
            {
                fixed (uint* valueFixed = array)
                {
                    value = *valueFixed;
                    for (uint* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static uint max(this uint[] array, uint TmphNullValue)
        {
            uint value;
            return max(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this TValueType[] array, Func<TValueType, uint> getKey, out uint value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (TValueType nextValue in array)
                {
                    uint nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static uint maxKey<TValueType>
            (this TValueType[] array, Func<TValueType, uint> getKey, uint TmphNullValue)
        {
            uint value;
            return maxKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this TValueType[] array, Func<TValueType, uint> getKey, out TValueType value)
        {
            if (array.length() != 0)
            {
                uint maxKey = getKey(value = array[0]);
                foreach (TValueType nextValue in array)
                {
                    uint nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>(this TValueType[] array, Func<TValueType, uint> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return max(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this uint[] array, out uint value)
        {
            if (array.length() != 0)
            {
                fixed (uint* valueFixed = array)
                {
                    value = *valueFixed;
                    for (uint* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = uint.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static uint min(this uint[] array, uint TmphNullValue)
        {
            uint value;
            return min(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this TValueType[] array, Func<TValueType, uint> getKey, out uint value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (TValueType nextValue in array)
                {
                    uint nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = uint.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static uint minKey<TValueType>
            (this TValueType[] array, Func<TValueType, uint> getKey, uint TmphNullValue)
        {
            uint value;
            return minKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>(this TValueType[] array, Func<TValueType, uint> getKey, out TValueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                uint minKey = getKey(value);
                foreach (TValueType nextValue in array)
                {
                    uint nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>(this TValueType[] array, Func<TValueType, uint> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return min(array, getKey, out value) ? value : TmphNullValue;
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static uint[] getReverse(this TmphSubArray<uint> array)
        {
            if (array.Count == 0) return TmphNullValue<uint>.Array;
            return TmphArrayExtension.GetReverse(array.Array, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static TmphSubArray<uint> reverse(this TmphSubArray<uint> array)
        {
            if (array.Count > 1) TmphArrayExtension.Reverse(array.Array, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this TmphSubArray<uint> array, uint value)
        {
            if (array.Count != 0)
            {
                fixed (uint* valueFixed = array.Array)
                {
                    uint* start = valueFixed + array.StartIndex, index = TmphArrayExtension.IndexOf(start, array.Count, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this TmphSubArray<uint> array, Func<uint, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (uint* valueFixed = array.Array)
                {
                    uint* start = valueFixed + array.StartIndex, index = TmphArrayExtension.IndexOf(start, array.Count, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(uint)</returns>
        public unsafe static uint firstOrDefault
            (this TmphSubArray<uint> array, Func<uint, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Count)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (uint* valueFixed = array.Array)
                {
                    uint* valueIndex = TmphArrayExtension.IndexOf(valueFixed + array.StartIndex + index, array.Count - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(uint);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count(this TmphSubArray<uint> array, Func<uint, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int value = 0;
                fixed (uint* valueFixed = array.Array)
                {
                    uint* start = valueFixed + array.StartIndex, end = start + array.Count;
                    do
                    {
                        if (isValue(*start)) ++value;
                    }
                    while (++start != end);
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static TmphSubArray<uint> replaceFirst
            (this TmphSubArray<uint> array, uint value, Func<uint, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (uint* valueFixed = array.Array)
                {
                    uint* valueIndex = TmphArrayExtension.IndexOf(valueFixed + array.StartIndex, array.Count, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<uint> find
            (this TmphSubArray<uint> array, Func<uint, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (uint* valueFixed = array.Array)
                {
                    uint* write = valueFixed + array.StartIndex, start = write, end = write + array.Count;
                    do
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    while (++start != end);
                    return TmphSubArray<uint>.Unsafe(array.Array, array.StartIndex, (int)(write - valueFixed) - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<uint> getFind
            (this TmphSubArray<uint> array, Func<uint, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                return TmphArrayExtension.GetFind(array.Array, array.StartIndex, array.Count, isValue);
            }
            return default(TmphSubArray<uint>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static uint[] getFindArray
            (this TmphSubArray<uint> array, Func<uint, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int length = ((array.Count + 31) >> 5) << 2;
                TmphMemoryPool pool = Laurent.Lee.CLB.TmphMemoryPool.GetDefaultPool(length);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return TmphArrayExtension.GetFindArray(array.Array, array.StartIndex, array.Count, isValue, new TmphFixedMap(dataFixed));
                    }
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<uint>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static uint[] getArray<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, uint> getValue)
        {
            if (TmphSubArray.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] array = TmphSubArray.Array;
                uint[] newValues = new uint[TmphSubArray.Count];
                fixed (uint* newValueFixed = newValues)
                {
                    uint* write = newValueFixed;
                    int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                    do
                    {
                        *write++ = getValue(array[index++]);
                    }
                    while (index != endIndex);
                }
                return newValues;
            }
            return TmphNullValue<uint>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static TValueType[] getArray<TValueType>
            (this TmphSubArray<uint> array, Func<uint, TValueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] newValues = new TValueType[array.Count];
                fixed (uint* arrayFixed = array.Array)
                {
                    uint* start = arrayFixed + array.StartIndex, end = start + array.Count;
                    int index = 0;
                    do
                    {
                        newValues[index++] = getValue(*start);
                    }
                    while (++start != end);
                }
                return newValues;
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static TmphSubArray<uint> each
            (this TmphSubArray<uint> array, Action<uint> method)
        {
            if (array.Count != 0)
            {
                if (method == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (uint* valueFixed = array.Array)
                {
                    for (uint* start = valueFixed + array.StartIndex, end = start + array.Count; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this TmphSubArray<uint> array, out uint value)
        {
            if (array.Count != 0)
            {
                fixed (uint* valueFixed = array.Array)
                {
                    uint* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static uint max(this TmphSubArray<uint> array, uint TmphNullValue)
        {
            uint value;
            return max(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, uint> getKey, out uint value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    uint nextKey = getKey(array[index]);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static uint maxKey<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, uint> getKey, uint TmphNullValue)
        {
            uint value;
            return maxKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, uint> getKey, out TValueType value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                uint maxKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    TValueType nextValue = array[index];
                    uint nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, uint> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return max(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this TmphSubArray<uint> array, out uint value)
        {
            if (array.Count != 0)
            {
                fixed (uint* valueFixed = array.Array)
                {
                    uint* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static uint min(this TmphSubArray<uint> array, uint TmphNullValue)
        {
            uint value;
            return min(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, uint> getKey, out uint value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    uint nextKey = getKey(array[index]);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static uint minKey<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, uint> getKey, uint TmphNullValue)
        {
            uint value;
            return minKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, uint> getKey, out TValueType value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                uint minKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    TValueType nextValue = array[index];
                    uint nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, uint> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return min(array, getKey, out value) ? value : TmphNullValue;
        }
    }
}

namespace Laurent.Lee.CLB.Unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void Move(uint[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (uint* valueFixed = array)
                {
                    for (uint* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (uint* valueFixed = array) Win32.TmphKernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(uint));
#endif
        }
    }
}
namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        public unsafe static void Reverse(int[] array, int index, int length)
        {
            fixed (int* valueFixed = array)
            {
                for (int* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    int value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static int[] reverse(this int[] array)
        {
            if (array == null || array.Length == 0) return TmphNullValue<int>.Array;
            Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        public unsafe static int[] GetReverse(int[] array, int index, int length)
        {
            int[] newValues = new int[length];
            fixed (int* valueFixed = array, newValueFixed = newValues)
            {
                for (int* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end;
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static int[] getReverse(this int[] array)
        {
            if (array == null || array.Length == 0) return TmphNullValue<int>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        public unsafe static int* IndexOf
            (int* valueFixed, int length, int value)
        {
            for (int* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this int[] array, int value)
        {
            if (array != null)
            {
                fixed (int* valueFixed = array)
                {
                    int* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        public unsafe static int* IndexOf
            (int* valueFixed, int length, Func<int, bool> isValue)
        {
            for (int* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this int[] array, Func<int, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (int* valueFixed = array)
                {
                    int* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(int)</returns>
        public unsafe static int firstOrDefault
            (this int[] array, Func<int, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (int* valueFixed = array)
                {
                    int* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(int);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this int[] array, Func<int, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int value = 0;
                fixed (int* valueFixed = array)
                {
                    for (int* end = valueFixed + array.Length; end != valueFixed; )
                    {
                        if (isValue(*--end)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static int[] replaceFirst
            (this int[] array, int value, Func<int, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (int* valueFixed = array)
                {
                    int* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return TmphNullValue<int>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static int[] getArray<TValueType>
            (this TValueType[] array, Func<TValueType, int> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int[] newValues = new int[array.Length];
                fixed (int* newValueFixed = newValues)
                {
                    int* writeValue = newValueFixed;
                    foreach (TValueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return TmphNullValue<int>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<int> GetFind
            (this int[] array, int index, int length, Func<int, bool> isValue)
        {
            int[] newValues = new int[length < sizeof(int) ? sizeof(int) : length];
            fixed (int* newValueFixed = newValues, valueFixed = array)
            {
                int* write = newValueFixed;
                for (int* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return TmphSubArray<int>.Unsafe(newValues, 0, (int)(write - newValueFixed));
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<int> getFind
            (this int[] array, Func<int, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                return GetFind(array, 0, array.Length, isValue);
            }
            return default(TmphSubArray<int>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static int[] getFindArray
            (this int[] array, Func<int, bool> isValue)
        {
            if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                TmphMemoryPool pool = Laurent.Lee.CLB.TmphMemoryPool.GetDefaultPool(length = ((length + 31) >> 5) << 2);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return GetFindArray(array, 0, array.Length, isValue, new TmphFixedMap(dataFixed));
                    }
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<int>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        public unsafe static int[] GetFindArray
            (int[] array, int index, int count, Func<int, bool> isValue, TmphFixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (int* valueFixed = array)
            {
                int* startFixed = valueFixed + index, end = startFixed + count;
                for (int* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    int[] newValues = new int[length];
                    fixed (int* newValueFixed = newValues)
                    {
                        int* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return TmphNullValue<int>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this int[] array, out int value)
        {
            if (array.length() != 0)
            {
                fixed (int* valueFixed = array)
                {
                    value = *valueFixed;
                    for (int* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static int max(this int[] array, int TmphNullValue)
        {
            int value;
            return max(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this TValueType[] array, Func<TValueType, int> getKey, out int value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (TValueType nextValue in array)
                {
                    int nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static int maxKey<TValueType>
            (this TValueType[] array, Func<TValueType, int> getKey, int TmphNullValue)
        {
            int value;
            return maxKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this TValueType[] array, Func<TValueType, int> getKey, out TValueType value)
        {
            if (array.length() != 0)
            {
                int maxKey = getKey(value = array[0]);
                foreach (TValueType nextValue in array)
                {
                    int nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>(this TValueType[] array, Func<TValueType, int> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return max(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this int[] array, out int value)
        {
            if (array.length() != 0)
            {
                fixed (int* valueFixed = array)
                {
                    value = *valueFixed;
                    for (int* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = int.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static int min(this int[] array, int TmphNullValue)
        {
            int value;
            return min(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this TValueType[] array, Func<TValueType, int> getKey, out int value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (TValueType nextValue in array)
                {
                    int nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = int.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static int minKey<TValueType>
            (this TValueType[] array, Func<TValueType, int> getKey, int TmphNullValue)
        {
            int value;
            return minKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>(this TValueType[] array, Func<TValueType, int> getKey, out TValueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                int minKey = getKey(value);
                foreach (TValueType nextValue in array)
                {
                    int nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>(this TValueType[] array, Func<TValueType, int> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return min(array, getKey, out value) ? value : TmphNullValue;
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static int[] getReverse(this TmphSubArray<int> array)
        {
            if (array.Count == 0) return TmphNullValue<int>.Array;
            return TmphArrayExtension.GetReverse(array.Array, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static TmphSubArray<int> reverse(this TmphSubArray<int> array)
        {
            if (array.Count > 1) TmphArrayExtension.Reverse(array.Array, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this TmphSubArray<int> array, int value)
        {
            if (array.Count != 0)
            {
                fixed (int* valueFixed = array.Array)
                {
                    int* start = valueFixed + array.StartIndex, index = TmphArrayExtension.IndexOf(start, array.Count, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this TmphSubArray<int> array, Func<int, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (int* valueFixed = array.Array)
                {
                    int* start = valueFixed + array.StartIndex, index = TmphArrayExtension.IndexOf(start, array.Count, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(int)</returns>
        public unsafe static int firstOrDefault
            (this TmphSubArray<int> array, Func<int, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Count)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (int* valueFixed = array.Array)
                {
                    int* valueIndex = TmphArrayExtension.IndexOf(valueFixed + array.StartIndex + index, array.Count - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(int);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count(this TmphSubArray<int> array, Func<int, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int value = 0;
                fixed (int* valueFixed = array.Array)
                {
                    int* start = valueFixed + array.StartIndex, end = start + array.Count;
                    do
                    {
                        if (isValue(*start)) ++value;
                    }
                    while (++start != end);
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static TmphSubArray<int> replaceFirst
            (this TmphSubArray<int> array, int value, Func<int, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (int* valueFixed = array.Array)
                {
                    int* valueIndex = TmphArrayExtension.IndexOf(valueFixed + array.StartIndex, array.Count, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<int> find
            (this TmphSubArray<int> array, Func<int, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (int* valueFixed = array.Array)
                {
                    int* write = valueFixed + array.StartIndex, start = write, end = write + array.Count;
                    do
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    while (++start != end);
                    return TmphSubArray<int>.Unsafe(array.Array, array.StartIndex, (int)(write - valueFixed) - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<int> getFind
            (this TmphSubArray<int> array, Func<int, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                return TmphArrayExtension.GetFind(array.Array, array.StartIndex, array.Count, isValue);
            }
            return default(TmphSubArray<int>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static int[] getFindArray
            (this TmphSubArray<int> array, Func<int, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int length = ((array.Count + 31) >> 5) << 2;
                TmphMemoryPool pool = Laurent.Lee.CLB.TmphMemoryPool.GetDefaultPool(length);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return TmphArrayExtension.GetFindArray(array.Array, array.StartIndex, array.Count, isValue, new TmphFixedMap(dataFixed));
                    }
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<int>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static int[] getArray<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, int> getValue)
        {
            if (TmphSubArray.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] array = TmphSubArray.Array;
                int[] newValues = new int[TmphSubArray.Count];
                fixed (int* newValueFixed = newValues)
                {
                    int* write = newValueFixed;
                    int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                    do
                    {
                        *write++ = getValue(array[index++]);
                    }
                    while (index != endIndex);
                }
                return newValues;
            }
            return TmphNullValue<int>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static TValueType[] getArray<TValueType>
            (this TmphSubArray<int> array, Func<int, TValueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] newValues = new TValueType[array.Count];
                fixed (int* arrayFixed = array.Array)
                {
                    int* start = arrayFixed + array.StartIndex, end = start + array.Count;
                    int index = 0;
                    do
                    {
                        newValues[index++] = getValue(*start);
                    }
                    while (++start != end);
                }
                return newValues;
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static TmphSubArray<int> each
            (this TmphSubArray<int> array, Action<int> method)
        {
            if (array.Count != 0)
            {
                if (method == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (int* valueFixed = array.Array)
                {
                    for (int* start = valueFixed + array.StartIndex, end = start + array.Count; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this TmphSubArray<int> array, out int value)
        {
            if (array.Count != 0)
            {
                fixed (int* valueFixed = array.Array)
                {
                    int* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static int max(this TmphSubArray<int> array, int TmphNullValue)
        {
            int value;
            return max(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, int> getKey, out int value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    int nextKey = getKey(array[index]);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static int maxKey<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, int> getKey, int TmphNullValue)
        {
            int value;
            return maxKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, int> getKey, out TValueType value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                int maxKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    TValueType nextValue = array[index];
                    int nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, int> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return max(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this TmphSubArray<int> array, out int value)
        {
            if (array.Count != 0)
            {
                fixed (int* valueFixed = array.Array)
                {
                    int* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static int min(this TmphSubArray<int> array, int TmphNullValue)
        {
            int value;
            return min(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, int> getKey, out int value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    int nextKey = getKey(array[index]);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static int minKey<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, int> getKey, int TmphNullValue)
        {
            int value;
            return minKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, int> getKey, out TValueType value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                int minKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    TValueType nextValue = array[index];
                    int nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, int> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return min(array, getKey, out value) ? value : TmphNullValue;
        }
    }
}

namespace Laurent.Lee.CLB.Unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void Move(int[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (int* valueFixed = array)
                {
                    for (int* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (int* valueFixed = array) Win32.TmphKernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(int));
#endif
        }
    }
}
namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        public unsafe static void Reverse(ushort[] array, int index, int length)
        {
            fixed (ushort* valueFixed = array)
            {
                for (ushort* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    ushort value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static ushort[] reverse(this ushort[] array)
        {
            if (array == null || array.Length == 0) return TmphNullValue<ushort>.Array;
            Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        public unsafe static ushort[] GetReverse(ushort[] array, int index, int length)
        {
            ushort[] newValues = new ushort[length];
            fixed (ushort* valueFixed = array, newValueFixed = newValues)
            {
                for (ushort* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end;
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static ushort[] getReverse(this ushort[] array)
        {
            if (array == null || array.Length == 0) return TmphNullValue<ushort>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        public unsafe static ushort* IndexOf
            (ushort* valueFixed, int length, ushort value)
        {
            for (ushort* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this ushort[] array, ushort value)
        {
            if (array != null)
            {
                fixed (ushort* valueFixed = array)
                {
                    ushort* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        public unsafe static ushort* IndexOf
            (ushort* valueFixed, int length, Func<ushort, bool> isValue)
        {
            for (ushort* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this ushort[] array, Func<ushort, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (ushort* valueFixed = array)
                {
                    ushort* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(ushort)</returns>
        public unsafe static ushort firstOrDefault
            (this ushort[] array, Func<ushort, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (ushort* valueFixed = array)
                {
                    ushort* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(ushort);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this ushort[] array, Func<ushort, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int value = 0;
                fixed (ushort* valueFixed = array)
                {
                    for (ushort* end = valueFixed + array.Length; end != valueFixed; )
                    {
                        if (isValue(*--end)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static ushort[] replaceFirst
            (this ushort[] array, ushort value, Func<ushort, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (ushort* valueFixed = array)
                {
                    ushort* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return TmphNullValue<ushort>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static ushort[] getArray<TValueType>
            (this TValueType[] array, Func<TValueType, ushort> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                ushort[] newValues = new ushort[array.Length];
                fixed (ushort* newValueFixed = newValues)
                {
                    ushort* writeValue = newValueFixed;
                    foreach (TValueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return TmphNullValue<ushort>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<ushort> GetFind
            (this ushort[] array, int index, int length, Func<ushort, bool> isValue)
        {
            ushort[] newValues = new ushort[length < sizeof(int) ? sizeof(int) : length];
            fixed (ushort* newValueFixed = newValues, valueFixed = array)
            {
                ushort* write = newValueFixed;
                for (ushort* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return TmphSubArray<ushort>.Unsafe(newValues, 0, (int)(write - newValueFixed));
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<ushort> getFind
            (this ushort[] array, Func<ushort, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                return GetFind(array, 0, array.Length, isValue);
            }
            return default(TmphSubArray<ushort>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static ushort[] getFindArray
            (this ushort[] array, Func<ushort, bool> isValue)
        {
            if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                TmphMemoryPool pool = Laurent.Lee.CLB.TmphMemoryPool.GetDefaultPool(length = ((length + 31) >> 5) << 2);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return GetFindArray(array, 0, array.Length, isValue, new TmphFixedMap(dataFixed));
                    }
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<ushort>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        public unsafe static ushort[] GetFindArray
            (ushort[] array, int index, int count, Func<ushort, bool> isValue, TmphFixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (ushort* valueFixed = array)
            {
                ushort* startFixed = valueFixed + index, end = startFixed + count;
                for (ushort* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    ushort[] newValues = new ushort[length];
                    fixed (ushort* newValueFixed = newValues)
                    {
                        ushort* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return TmphNullValue<ushort>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this ushort[] array, out ushort value)
        {
            if (array.length() != 0)
            {
                fixed (ushort* valueFixed = array)
                {
                    value = *valueFixed;
                    for (ushort* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static ushort max(this ushort[] array, ushort TmphNullValue)
        {
            ushort value;
            return max(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this TValueType[] array, Func<TValueType, ushort> getKey, out ushort value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (TValueType nextValue in array)
                {
                    ushort nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static ushort maxKey<TValueType>
            (this TValueType[] array, Func<TValueType, ushort> getKey, ushort TmphNullValue)
        {
            ushort value;
            return maxKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this TValueType[] array, Func<TValueType, ushort> getKey, out TValueType value)
        {
            if (array.length() != 0)
            {
                ushort maxKey = getKey(value = array[0]);
                foreach (TValueType nextValue in array)
                {
                    ushort nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>(this TValueType[] array, Func<TValueType, ushort> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return max(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this ushort[] array, out ushort value)
        {
            if (array.length() != 0)
            {
                fixed (ushort* valueFixed = array)
                {
                    value = *valueFixed;
                    for (ushort* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = ushort.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static ushort min(this ushort[] array, ushort TmphNullValue)
        {
            ushort value;
            return min(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this TValueType[] array, Func<TValueType, ushort> getKey, out ushort value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (TValueType nextValue in array)
                {
                    ushort nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = ushort.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static ushort minKey<TValueType>
            (this TValueType[] array, Func<TValueType, ushort> getKey, ushort TmphNullValue)
        {
            ushort value;
            return minKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>(this TValueType[] array, Func<TValueType, ushort> getKey, out TValueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                ushort minKey = getKey(value);
                foreach (TValueType nextValue in array)
                {
                    ushort nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>(this TValueType[] array, Func<TValueType, ushort> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return min(array, getKey, out value) ? value : TmphNullValue;
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static ushort[] getReverse(this TmphSubArray<ushort> array)
        {
            if (array.Count == 0) return TmphNullValue<ushort>.Array;
            return TmphArrayExtension.GetReverse(array.Array, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static TmphSubArray<ushort> reverse(this TmphSubArray<ushort> array)
        {
            if (array.Count > 1) TmphArrayExtension.Reverse(array.Array, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this TmphSubArray<ushort> array, ushort value)
        {
            if (array.Count != 0)
            {
                fixed (ushort* valueFixed = array.Array)
                {
                    ushort* start = valueFixed + array.StartIndex, index = TmphArrayExtension.IndexOf(start, array.Count, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this TmphSubArray<ushort> array, Func<ushort, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (ushort* valueFixed = array.Array)
                {
                    ushort* start = valueFixed + array.StartIndex, index = TmphArrayExtension.IndexOf(start, array.Count, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(ushort)</returns>
        public unsafe static ushort firstOrDefault
            (this TmphSubArray<ushort> array, Func<ushort, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Count)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (ushort* valueFixed = array.Array)
                {
                    ushort* valueIndex = TmphArrayExtension.IndexOf(valueFixed + array.StartIndex + index, array.Count - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(ushort);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count(this TmphSubArray<ushort> array, Func<ushort, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int value = 0;
                fixed (ushort* valueFixed = array.Array)
                {
                    ushort* start = valueFixed + array.StartIndex, end = start + array.Count;
                    do
                    {
                        if (isValue(*start)) ++value;
                    }
                    while (++start != end);
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static TmphSubArray<ushort> replaceFirst
            (this TmphSubArray<ushort> array, ushort value, Func<ushort, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (ushort* valueFixed = array.Array)
                {
                    ushort* valueIndex = TmphArrayExtension.IndexOf(valueFixed + array.StartIndex, array.Count, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<ushort> find
            (this TmphSubArray<ushort> array, Func<ushort, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (ushort* valueFixed = array.Array)
                {
                    ushort* write = valueFixed + array.StartIndex, start = write, end = write + array.Count;
                    do
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    while (++start != end);
                    return TmphSubArray<ushort>.Unsafe(array.Array, array.StartIndex, (int)(write - valueFixed) - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<ushort> getFind
            (this TmphSubArray<ushort> array, Func<ushort, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                return TmphArrayExtension.GetFind(array.Array, array.StartIndex, array.Count, isValue);
            }
            return default(TmphSubArray<ushort>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static ushort[] getFindArray
            (this TmphSubArray<ushort> array, Func<ushort, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int length = ((array.Count + 31) >> 5) << 2;
                TmphMemoryPool pool = Laurent.Lee.CLB.TmphMemoryPool.GetDefaultPool(length);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return TmphArrayExtension.GetFindArray(array.Array, array.StartIndex, array.Count, isValue, new TmphFixedMap(dataFixed));
                    }
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<ushort>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static ushort[] getArray<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, ushort> getValue)
        {
            if (TmphSubArray.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] array = TmphSubArray.Array;
                ushort[] newValues = new ushort[TmphSubArray.Count];
                fixed (ushort* newValueFixed = newValues)
                {
                    ushort* write = newValueFixed;
                    int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                    do
                    {
                        *write++ = getValue(array[index++]);
                    }
                    while (index != endIndex);
                }
                return newValues;
            }
            return TmphNullValue<ushort>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static TValueType[] getArray<TValueType>
            (this TmphSubArray<ushort> array, Func<ushort, TValueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] newValues = new TValueType[array.Count];
                fixed (ushort* arrayFixed = array.Array)
                {
                    ushort* start = arrayFixed + array.StartIndex, end = start + array.Count;
                    int index = 0;
                    do
                    {
                        newValues[index++] = getValue(*start);
                    }
                    while (++start != end);
                }
                return newValues;
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static TmphSubArray<ushort> each
            (this TmphSubArray<ushort> array, Action<ushort> method)
        {
            if (array.Count != 0)
            {
                if (method == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (ushort* valueFixed = array.Array)
                {
                    for (ushort* start = valueFixed + array.StartIndex, end = start + array.Count; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this TmphSubArray<ushort> array, out ushort value)
        {
            if (array.Count != 0)
            {
                fixed (ushort* valueFixed = array.Array)
                {
                    ushort* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static ushort max(this TmphSubArray<ushort> array, ushort TmphNullValue)
        {
            ushort value;
            return max(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, ushort> getKey, out ushort value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    ushort nextKey = getKey(array[index]);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static ushort maxKey<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, ushort> getKey, ushort TmphNullValue)
        {
            ushort value;
            return maxKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, ushort> getKey, out TValueType value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                ushort maxKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    TValueType nextValue = array[index];
                    ushort nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, ushort> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return max(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this TmphSubArray<ushort> array, out ushort value)
        {
            if (array.Count != 0)
            {
                fixed (ushort* valueFixed = array.Array)
                {
                    ushort* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static ushort min(this TmphSubArray<ushort> array, ushort TmphNullValue)
        {
            ushort value;
            return min(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, ushort> getKey, out ushort value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    ushort nextKey = getKey(array[index]);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static ushort minKey<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, ushort> getKey, ushort TmphNullValue)
        {
            ushort value;
            return minKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, ushort> getKey, out TValueType value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                ushort minKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    TValueType nextValue = array[index];
                    ushort nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, ushort> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return min(array, getKey, out value) ? value : TmphNullValue;
        }
    }
}

namespace Laurent.Lee.CLB.Unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void Move(ushort[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (ushort* valueFixed = array)
                {
                    for (ushort* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (ushort* valueFixed = array) Win32.TmphKernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(ushort));
#endif
        }
    }
}
namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        public unsafe static void Reverse(short[] array, int index, int length)
        {
            fixed (short* valueFixed = array)
            {
                for (short* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    short value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static short[] reverse(this short[] array)
        {
            if (array == null || array.Length == 0) return TmphNullValue<short>.Array;
            Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        public unsafe static short[] GetReverse(short[] array, int index, int length)
        {
            short[] newValues = new short[length];
            fixed (short* valueFixed = array, newValueFixed = newValues)
            {
                for (short* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end;
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static short[] getReverse(this short[] array)
        {
            if (array == null || array.Length == 0) return TmphNullValue<short>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        public unsafe static short* IndexOf
            (short* valueFixed, int length, short value)
        {
            for (short* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this short[] array, short value)
        {
            if (array != null)
            {
                fixed (short* valueFixed = array)
                {
                    short* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        public unsafe static short* IndexOf
            (short* valueFixed, int length, Func<short, bool> isValue)
        {
            for (short* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this short[] array, Func<short, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (short* valueFixed = array)
                {
                    short* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(short)</returns>
        public unsafe static short firstOrDefault
            (this short[] array, Func<short, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (short* valueFixed = array)
                {
                    short* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(short);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this short[] array, Func<short, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int value = 0;
                fixed (short* valueFixed = array)
                {
                    for (short* end = valueFixed + array.Length; end != valueFixed; )
                    {
                        if (isValue(*--end)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static short[] replaceFirst
            (this short[] array, short value, Func<short, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (short* valueFixed = array)
                {
                    short* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return TmphNullValue<short>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static short[] getArray<TValueType>
            (this TValueType[] array, Func<TValueType, short> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                short[] newValues = new short[array.Length];
                fixed (short* newValueFixed = newValues)
                {
                    short* writeValue = newValueFixed;
                    foreach (TValueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return TmphNullValue<short>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<short> GetFind
            (this short[] array, int index, int length, Func<short, bool> isValue)
        {
            short[] newValues = new short[length < sizeof(int) ? sizeof(int) : length];
            fixed (short* newValueFixed = newValues, valueFixed = array)
            {
                short* write = newValueFixed;
                for (short* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return TmphSubArray<short>.Unsafe(newValues, 0, (int)(write - newValueFixed));
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<short> getFind
            (this short[] array, Func<short, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                return GetFind(array, 0, array.Length, isValue);
            }
            return default(TmphSubArray<short>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static short[] getFindArray
            (this short[] array, Func<short, bool> isValue)
        {
            if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                TmphMemoryPool pool = Laurent.Lee.CLB.TmphMemoryPool.GetDefaultPool(length = ((length + 31) >> 5) << 2);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return GetFindArray(array, 0, array.Length, isValue, new TmphFixedMap(dataFixed));
                    }
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<short>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        public unsafe static short[] GetFindArray
            (short[] array, int index, int count, Func<short, bool> isValue, TmphFixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (short* valueFixed = array)
            {
                short* startFixed = valueFixed + index, end = startFixed + count;
                for (short* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    short[] newValues = new short[length];
                    fixed (short* newValueFixed = newValues)
                    {
                        short* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return TmphNullValue<short>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this short[] array, out short value)
        {
            if (array.length() != 0)
            {
                fixed (short* valueFixed = array)
                {
                    value = *valueFixed;
                    for (short* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static short max(this short[] array, short TmphNullValue)
        {
            short value;
            return max(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this TValueType[] array, Func<TValueType, short> getKey, out short value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (TValueType nextValue in array)
                {
                    short nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static short maxKey<TValueType>
            (this TValueType[] array, Func<TValueType, short> getKey, short TmphNullValue)
        {
            short value;
            return maxKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this TValueType[] array, Func<TValueType, short> getKey, out TValueType value)
        {
            if (array.length() != 0)
            {
                short maxKey = getKey(value = array[0]);
                foreach (TValueType nextValue in array)
                {
                    short nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>(this TValueType[] array, Func<TValueType, short> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return max(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this short[] array, out short value)
        {
            if (array.length() != 0)
            {
                fixed (short* valueFixed = array)
                {
                    value = *valueFixed;
                    for (short* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = short.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static short min(this short[] array, short TmphNullValue)
        {
            short value;
            return min(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this TValueType[] array, Func<TValueType, short> getKey, out short value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (TValueType nextValue in array)
                {
                    short nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = short.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static short minKey<TValueType>
            (this TValueType[] array, Func<TValueType, short> getKey, short TmphNullValue)
        {
            short value;
            return minKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>(this TValueType[] array, Func<TValueType, short> getKey, out TValueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                short minKey = getKey(value);
                foreach (TValueType nextValue in array)
                {
                    short nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>(this TValueType[] array, Func<TValueType, short> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return min(array, getKey, out value) ? value : TmphNullValue;
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static short[] getReverse(this TmphSubArray<short> array)
        {
            if (array.Count == 0) return TmphNullValue<short>.Array;
            return TmphArrayExtension.GetReverse(array.Array, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static TmphSubArray<short> reverse(this TmphSubArray<short> array)
        {
            if (array.Count > 1) TmphArrayExtension.Reverse(array.Array, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this TmphSubArray<short> array, short value)
        {
            if (array.Count != 0)
            {
                fixed (short* valueFixed = array.Array)
                {
                    short* start = valueFixed + array.StartIndex, index = TmphArrayExtension.IndexOf(start, array.Count, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this TmphSubArray<short> array, Func<short, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (short* valueFixed = array.Array)
                {
                    short* start = valueFixed + array.StartIndex, index = TmphArrayExtension.IndexOf(start, array.Count, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(short)</returns>
        public unsafe static short firstOrDefault
            (this TmphSubArray<short> array, Func<short, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Count)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (short* valueFixed = array.Array)
                {
                    short* valueIndex = TmphArrayExtension.IndexOf(valueFixed + array.StartIndex + index, array.Count - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(short);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count(this TmphSubArray<short> array, Func<short, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int value = 0;
                fixed (short* valueFixed = array.Array)
                {
                    short* start = valueFixed + array.StartIndex, end = start + array.Count;
                    do
                    {
                        if (isValue(*start)) ++value;
                    }
                    while (++start != end);
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static TmphSubArray<short> replaceFirst
            (this TmphSubArray<short> array, short value, Func<short, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (short* valueFixed = array.Array)
                {
                    short* valueIndex = TmphArrayExtension.IndexOf(valueFixed + array.StartIndex, array.Count, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<short> find
            (this TmphSubArray<short> array, Func<short, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (short* valueFixed = array.Array)
                {
                    short* write = valueFixed + array.StartIndex, start = write, end = write + array.Count;
                    do
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    while (++start != end);
                    return TmphSubArray<short>.Unsafe(array.Array, array.StartIndex, (int)(write - valueFixed) - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<short> getFind
            (this TmphSubArray<short> array, Func<short, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                return TmphArrayExtension.GetFind(array.Array, array.StartIndex, array.Count, isValue);
            }
            return default(TmphSubArray<short>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static short[] getFindArray
            (this TmphSubArray<short> array, Func<short, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int length = ((array.Count + 31) >> 5) << 2;
                TmphMemoryPool pool = Laurent.Lee.CLB.TmphMemoryPool.GetDefaultPool(length);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return TmphArrayExtension.GetFindArray(array.Array, array.StartIndex, array.Count, isValue, new TmphFixedMap(dataFixed));
                    }
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<short>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static short[] getArray<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, short> getValue)
        {
            if (TmphSubArray.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] array = TmphSubArray.Array;
                short[] newValues = new short[TmphSubArray.Count];
                fixed (short* newValueFixed = newValues)
                {
                    short* write = newValueFixed;
                    int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                    do
                    {
                        *write++ = getValue(array[index++]);
                    }
                    while (index != endIndex);
                }
                return newValues;
            }
            return TmphNullValue<short>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static TValueType[] getArray<TValueType>
            (this TmphSubArray<short> array, Func<short, TValueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] newValues = new TValueType[array.Count];
                fixed (short* arrayFixed = array.Array)
                {
                    short* start = arrayFixed + array.StartIndex, end = start + array.Count;
                    int index = 0;
                    do
                    {
                        newValues[index++] = getValue(*start);
                    }
                    while (++start != end);
                }
                return newValues;
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static TmphSubArray<short> each
            (this TmphSubArray<short> array, Action<short> method)
        {
            if (array.Count != 0)
            {
                if (method == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (short* valueFixed = array.Array)
                {
                    for (short* start = valueFixed + array.StartIndex, end = start + array.Count; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this TmphSubArray<short> array, out short value)
        {
            if (array.Count != 0)
            {
                fixed (short* valueFixed = array.Array)
                {
                    short* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static short max(this TmphSubArray<short> array, short TmphNullValue)
        {
            short value;
            return max(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, short> getKey, out short value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    short nextKey = getKey(array[index]);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static short maxKey<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, short> getKey, short TmphNullValue)
        {
            short value;
            return maxKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, short> getKey, out TValueType value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                short maxKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    TValueType nextValue = array[index];
                    short nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, short> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return max(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this TmphSubArray<short> array, out short value)
        {
            if (array.Count != 0)
            {
                fixed (short* valueFixed = array.Array)
                {
                    short* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static short min(this TmphSubArray<short> array, short TmphNullValue)
        {
            short value;
            return min(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, short> getKey, out short value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    short nextKey = getKey(array[index]);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static short minKey<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, short> getKey, short TmphNullValue)
        {
            short value;
            return minKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, short> getKey, out TValueType value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                short minKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    TValueType nextValue = array[index];
                    short nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, short> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return min(array, getKey, out value) ? value : TmphNullValue;
        }
    }
}

namespace Laurent.Lee.CLB.Unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void Move(short[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (short* valueFixed = array)
                {
                    for (short* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (short* valueFixed = array) Win32.TmphKernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(short));
#endif
        }
    }
}
namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        public unsafe static void Reverse(byte[] array, int index, int length)
        {
            fixed (byte* valueFixed = array)
            {
                for (byte* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    byte value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static byte[] reverse(this byte[] array)
        {
            if (array == null || array.Length == 0) return TmphNullValue<byte>.Array;
            Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        public unsafe static byte[] GetReverse(byte[] array, int index, int length)
        {
            byte[] newValues = new byte[length];
            fixed (byte* valueFixed = array, newValueFixed = newValues)
            {
                for (byte* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end;
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static byte[] getReverse(this byte[] array)
        {
            if (array == null || array.Length == 0) return TmphNullValue<byte>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        public unsafe static byte* IndexOf
            (byte* valueFixed, int length, byte value)
        {
            for (byte* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this byte[] array, byte value)
        {
            if (array != null)
            {
                fixed (byte* valueFixed = array)
                {
                    byte* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        public unsafe static byte* IndexOf
            (byte* valueFixed, int length, Func<byte, bool> isValue)
        {
            for (byte* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this byte[] array, Func<byte, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (byte* valueFixed = array)
                {
                    byte* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(byte)</returns>
        public unsafe static byte firstOrDefault
            (this byte[] array, Func<byte, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (byte* valueFixed = array)
                {
                    byte* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(byte);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this byte[] array, Func<byte, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int value = 0;
                fixed (byte* valueFixed = array)
                {
                    for (byte* end = valueFixed + array.Length; end != valueFixed; )
                    {
                        if (isValue(*--end)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static byte[] replaceFirst
            (this byte[] array, byte value, Func<byte, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (byte* valueFixed = array)
                {
                    byte* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return TmphNullValue<byte>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static byte[] getArray<TValueType>
            (this TValueType[] array, Func<TValueType, byte> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                byte[] newValues = new byte[array.Length];
                fixed (byte* newValueFixed = newValues)
                {
                    byte* writeValue = newValueFixed;
                    foreach (TValueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return TmphNullValue<byte>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<byte> GetFind
            (this byte[] array, int index, int length, Func<byte, bool> isValue)
        {
            byte[] newValues = new byte[length < sizeof(int) ? sizeof(int) : length];
            fixed (byte* newValueFixed = newValues, valueFixed = array)
            {
                byte* write = newValueFixed;
                for (byte* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return TmphSubArray<byte>.Unsafe(newValues, 0, (int)(write - newValueFixed));
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<byte> getFind
            (this byte[] array, Func<byte, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                return GetFind(array, 0, array.Length, isValue);
            }
            return default(TmphSubArray<byte>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static byte[] getFindArray
            (this byte[] array, Func<byte, bool> isValue)
        {
            if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                TmphMemoryPool pool = Laurent.Lee.CLB.TmphMemoryPool.GetDefaultPool(length = ((length + 31) >> 5) << 2);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return GetFindArray(array, 0, array.Length, isValue, new TmphFixedMap(dataFixed));
                    }
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<byte>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        public unsafe static byte[] GetFindArray
            (byte[] array, int index, int count, Func<byte, bool> isValue, TmphFixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (byte* valueFixed = array)
            {
                byte* startFixed = valueFixed + index, end = startFixed + count;
                for (byte* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    byte[] newValues = new byte[length];
                    fixed (byte* newValueFixed = newValues)
                    {
                        byte* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return TmphNullValue<byte>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this byte[] array, out byte value)
        {
            if (array.length() != 0)
            {
                fixed (byte* valueFixed = array)
                {
                    value = *valueFixed;
                    for (byte* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static byte max(this byte[] array, byte TmphNullValue)
        {
            byte value;
            return max(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this TValueType[] array, Func<TValueType, byte> getKey, out byte value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (TValueType nextValue in array)
                {
                    byte nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static byte maxKey<TValueType>
            (this TValueType[] array, Func<TValueType, byte> getKey, byte TmphNullValue)
        {
            byte value;
            return maxKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this TValueType[] array, Func<TValueType, byte> getKey, out TValueType value)
        {
            if (array.length() != 0)
            {
                byte maxKey = getKey(value = array[0]);
                foreach (TValueType nextValue in array)
                {
                    byte nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>(this TValueType[] array, Func<TValueType, byte> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return max(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this byte[] array, out byte value)
        {
            if (array.length() != 0)
            {
                fixed (byte* valueFixed = array)
                {
                    value = *valueFixed;
                    for (byte* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = byte.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static byte min(this byte[] array, byte TmphNullValue)
        {
            byte value;
            return min(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this TValueType[] array, Func<TValueType, byte> getKey, out byte value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (TValueType nextValue in array)
                {
                    byte nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = byte.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static byte minKey<TValueType>
            (this TValueType[] array, Func<TValueType, byte> getKey, byte TmphNullValue)
        {
            byte value;
            return minKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>(this TValueType[] array, Func<TValueType, byte> getKey, out TValueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                byte minKey = getKey(value);
                foreach (TValueType nextValue in array)
                {
                    byte nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>(this TValueType[] array, Func<TValueType, byte> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return min(array, getKey, out value) ? value : TmphNullValue;
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static byte[] getReverse(this TmphSubArray<byte> array)
        {
            if (array.Count == 0) return TmphNullValue<byte>.Array;
            return TmphArrayExtension.GetReverse(array.Array, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static TmphSubArray<byte> reverse(this TmphSubArray<byte> array)
        {
            if (array.Count > 1) TmphArrayExtension.Reverse(array.Array, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this TmphSubArray<byte> array, byte value)
        {
            if (array.Count != 0)
            {
                fixed (byte* valueFixed = array.Array)
                {
                    byte* start = valueFixed + array.StartIndex, index = TmphArrayExtension.IndexOf(start, array.Count, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this TmphSubArray<byte> array, Func<byte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (byte* valueFixed = array.Array)
                {
                    byte* start = valueFixed + array.StartIndex, index = TmphArrayExtension.IndexOf(start, array.Count, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(byte)</returns>
        public unsafe static byte firstOrDefault
            (this TmphSubArray<byte> array, Func<byte, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Count)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (byte* valueFixed = array.Array)
                {
                    byte* valueIndex = TmphArrayExtension.IndexOf(valueFixed + array.StartIndex + index, array.Count - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(byte);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count(this TmphSubArray<byte> array, Func<byte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int value = 0;
                fixed (byte* valueFixed = array.Array)
                {
                    byte* start = valueFixed + array.StartIndex, end = start + array.Count;
                    do
                    {
                        if (isValue(*start)) ++value;
                    }
                    while (++start != end);
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static TmphSubArray<byte> replaceFirst
            (this TmphSubArray<byte> array, byte value, Func<byte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (byte* valueFixed = array.Array)
                {
                    byte* valueIndex = TmphArrayExtension.IndexOf(valueFixed + array.StartIndex, array.Count, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<byte> find
            (this TmphSubArray<byte> array, Func<byte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (byte* valueFixed = array.Array)
                {
                    byte* write = valueFixed + array.StartIndex, start = write, end = write + array.Count;
                    do
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    while (++start != end);
                    return TmphSubArray<byte>.Unsafe(array.Array, array.StartIndex, (int)(write - valueFixed) - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<byte> getFind
            (this TmphSubArray<byte> array, Func<byte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                return TmphArrayExtension.GetFind(array.Array, array.StartIndex, array.Count, isValue);
            }
            return default(TmphSubArray<byte>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static byte[] getFindArray
            (this TmphSubArray<byte> array, Func<byte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int length = ((array.Count + 31) >> 5) << 2;
                TmphMemoryPool pool = Laurent.Lee.CLB.TmphMemoryPool.GetDefaultPool(length);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return TmphArrayExtension.GetFindArray(array.Array, array.StartIndex, array.Count, isValue, new TmphFixedMap(dataFixed));
                    }
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<byte>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static byte[] getArray<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, byte> getValue)
        {
            if (TmphSubArray.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] array = TmphSubArray.Array;
                byte[] newValues = new byte[TmphSubArray.Count];
                fixed (byte* newValueFixed = newValues)
                {
                    byte* write = newValueFixed;
                    int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                    do
                    {
                        *write++ = getValue(array[index++]);
                    }
                    while (index != endIndex);
                }
                return newValues;
            }
            return TmphNullValue<byte>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static TValueType[] getArray<TValueType>
            (this TmphSubArray<byte> array, Func<byte, TValueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] newValues = new TValueType[array.Count];
                fixed (byte* arrayFixed = array.Array)
                {
                    byte* start = arrayFixed + array.StartIndex, end = start + array.Count;
                    int index = 0;
                    do
                    {
                        newValues[index++] = getValue(*start);
                    }
                    while (++start != end);
                }
                return newValues;
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static TmphSubArray<byte> each
            (this TmphSubArray<byte> array, Action<byte> method)
        {
            if (array.Count != 0)
            {
                if (method == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (byte* valueFixed = array.Array)
                {
                    for (byte* start = valueFixed + array.StartIndex, end = start + array.Count; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this TmphSubArray<byte> array, out byte value)
        {
            if (array.Count != 0)
            {
                fixed (byte* valueFixed = array.Array)
                {
                    byte* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static byte max(this TmphSubArray<byte> array, byte TmphNullValue)
        {
            byte value;
            return max(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, byte> getKey, out byte value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    byte nextKey = getKey(array[index]);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static byte maxKey<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, byte> getKey, byte TmphNullValue)
        {
            byte value;
            return maxKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, byte> getKey, out TValueType value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                byte maxKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    TValueType nextValue = array[index];
                    byte nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, byte> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return max(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this TmphSubArray<byte> array, out byte value)
        {
            if (array.Count != 0)
            {
                fixed (byte* valueFixed = array.Array)
                {
                    byte* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static byte min(this TmphSubArray<byte> array, byte TmphNullValue)
        {
            byte value;
            return min(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, byte> getKey, out byte value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    byte nextKey = getKey(array[index]);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static byte minKey<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, byte> getKey, byte TmphNullValue)
        {
            byte value;
            return minKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, byte> getKey, out TValueType value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                byte minKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    TValueType nextValue = array[index];
                    byte nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, byte> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return min(array, getKey, out value) ? value : TmphNullValue;
        }
    }
}

namespace Laurent.Lee.CLB.Unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void Move(byte[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (byte* valueFixed = array)
                {
                    for (byte* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (byte* valueFixed = array) Win32.TmphKernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(byte));
#endif
        }
    }
}
namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        public unsafe static void Reverse(sbyte[] array, int index, int length)
        {
            fixed (sbyte* valueFixed = array)
            {
                for (sbyte* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    sbyte value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static sbyte[] reverse(this sbyte[] array)
        {
            if (array == null || array.Length == 0) return TmphNullValue<sbyte>.Array;
            Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        public unsafe static sbyte[] GetReverse(sbyte[] array, int index, int length)
        {
            sbyte[] newValues = new sbyte[length];
            fixed (sbyte* valueFixed = array, newValueFixed = newValues)
            {
                for (sbyte* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end;
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static sbyte[] getReverse(this sbyte[] array)
        {
            if (array == null || array.Length == 0) return TmphNullValue<sbyte>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        public unsafe static sbyte* IndexOf
            (sbyte* valueFixed, int length, sbyte value)
        {
            for (sbyte* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this sbyte[] array, sbyte value)
        {
            if (array != null)
            {
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        public unsafe static sbyte* IndexOf
            (sbyte* valueFixed, int length, Func<sbyte, bool> isValue)
        {
            for (sbyte* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this sbyte[] array, Func<sbyte, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(sbyte)</returns>
        public unsafe static sbyte firstOrDefault
            (this sbyte[] array, Func<sbyte, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(sbyte);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this sbyte[] array, Func<sbyte, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int value = 0;
                fixed (sbyte* valueFixed = array)
                {
                    for (sbyte* end = valueFixed + array.Length; end != valueFixed; )
                    {
                        if (isValue(*--end)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static sbyte[] replaceFirst
            (this sbyte[] array, sbyte value, Func<sbyte, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return TmphNullValue<sbyte>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static sbyte[] getArray<TValueType>
            (this TValueType[] array, Func<TValueType, sbyte> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                sbyte[] newValues = new sbyte[array.Length];
                fixed (sbyte* newValueFixed = newValues)
                {
                    sbyte* writeValue = newValueFixed;
                    foreach (TValueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return TmphNullValue<sbyte>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<sbyte> GetFind
            (this sbyte[] array, int index, int length, Func<sbyte, bool> isValue)
        {
            sbyte[] newValues = new sbyte[length < sizeof(int) ? sizeof(int) : length];
            fixed (sbyte* newValueFixed = newValues, valueFixed = array)
            {
                sbyte* write = newValueFixed;
                for (sbyte* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return TmphSubArray<sbyte>.Unsafe(newValues, 0, (int)(write - newValueFixed));
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<sbyte> getFind
            (this sbyte[] array, Func<sbyte, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                return GetFind(array, 0, array.Length, isValue);
            }
            return default(TmphSubArray<sbyte>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static sbyte[] getFindArray
            (this sbyte[] array, Func<sbyte, bool> isValue)
        {
            if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                TmphMemoryPool pool = Laurent.Lee.CLB.TmphMemoryPool.GetDefaultPool(length = ((length + 31) >> 5) << 2);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return GetFindArray(array, 0, array.Length, isValue, new TmphFixedMap(dataFixed));
                    }
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<sbyte>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        public unsafe static sbyte[] GetFindArray
            (sbyte[] array, int index, int count, Func<sbyte, bool> isValue, TmphFixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (sbyte* valueFixed = array)
            {
                sbyte* startFixed = valueFixed + index, end = startFixed + count;
                for (sbyte* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    sbyte[] newValues = new sbyte[length];
                    fixed (sbyte* newValueFixed = newValues)
                    {
                        sbyte* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return TmphNullValue<sbyte>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this sbyte[] array, out sbyte value)
        {
            if (array.length() != 0)
            {
                fixed (sbyte* valueFixed = array)
                {
                    value = *valueFixed;
                    for (sbyte* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static sbyte max(this sbyte[] array, sbyte TmphNullValue)
        {
            sbyte value;
            return max(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this TValueType[] array, Func<TValueType, sbyte> getKey, out sbyte value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (TValueType nextValue in array)
                {
                    sbyte nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static sbyte maxKey<TValueType>
            (this TValueType[] array, Func<TValueType, sbyte> getKey, sbyte TmphNullValue)
        {
            sbyte value;
            return maxKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this TValueType[] array, Func<TValueType, sbyte> getKey, out TValueType value)
        {
            if (array.length() != 0)
            {
                sbyte maxKey = getKey(value = array[0]);
                foreach (TValueType nextValue in array)
                {
                    sbyte nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>(this TValueType[] array, Func<TValueType, sbyte> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return max(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this sbyte[] array, out sbyte value)
        {
            if (array.length() != 0)
            {
                fixed (sbyte* valueFixed = array)
                {
                    value = *valueFixed;
                    for (sbyte* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = sbyte.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static sbyte min(this sbyte[] array, sbyte TmphNullValue)
        {
            sbyte value;
            return min(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this TValueType[] array, Func<TValueType, sbyte> getKey, out sbyte value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (TValueType nextValue in array)
                {
                    sbyte nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = sbyte.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static sbyte minKey<TValueType>
            (this TValueType[] array, Func<TValueType, sbyte> getKey, sbyte TmphNullValue)
        {
            sbyte value;
            return minKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>(this TValueType[] array, Func<TValueType, sbyte> getKey, out TValueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                sbyte minKey = getKey(value);
                foreach (TValueType nextValue in array)
                {
                    sbyte nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>(this TValueType[] array, Func<TValueType, sbyte> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return min(array, getKey, out value) ? value : TmphNullValue;
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static sbyte[] getReverse(this TmphSubArray<sbyte> array)
        {
            if (array.Count == 0) return TmphNullValue<sbyte>.Array;
            return TmphArrayExtension.GetReverse(array.Array, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static TmphSubArray<sbyte> reverse(this TmphSubArray<sbyte> array)
        {
            if (array.Count > 1) TmphArrayExtension.Reverse(array.Array, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this TmphSubArray<sbyte> array, sbyte value)
        {
            if (array.Count != 0)
            {
                fixed (sbyte* valueFixed = array.Array)
                {
                    sbyte* start = valueFixed + array.StartIndex, index = TmphArrayExtension.IndexOf(start, array.Count, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this TmphSubArray<sbyte> array, Func<sbyte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (sbyte* valueFixed = array.Array)
                {
                    sbyte* start = valueFixed + array.StartIndex, index = TmphArrayExtension.IndexOf(start, array.Count, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(sbyte)</returns>
        public unsafe static sbyte firstOrDefault
            (this TmphSubArray<sbyte> array, Func<sbyte, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Count)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (sbyte* valueFixed = array.Array)
                {
                    sbyte* valueIndex = TmphArrayExtension.IndexOf(valueFixed + array.StartIndex + index, array.Count - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(sbyte);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count(this TmphSubArray<sbyte> array, Func<sbyte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int value = 0;
                fixed (sbyte* valueFixed = array.Array)
                {
                    sbyte* start = valueFixed + array.StartIndex, end = start + array.Count;
                    do
                    {
                        if (isValue(*start)) ++value;
                    }
                    while (++start != end);
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static TmphSubArray<sbyte> replaceFirst
            (this TmphSubArray<sbyte> array, sbyte value, Func<sbyte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (sbyte* valueFixed = array.Array)
                {
                    sbyte* valueIndex = TmphArrayExtension.IndexOf(valueFixed + array.StartIndex, array.Count, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<sbyte> find
            (this TmphSubArray<sbyte> array, Func<sbyte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (sbyte* valueFixed = array.Array)
                {
                    sbyte* write = valueFixed + array.StartIndex, start = write, end = write + array.Count;
                    do
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    while (++start != end);
                    return TmphSubArray<sbyte>.Unsafe(array.Array, array.StartIndex, (int)(write - valueFixed) - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<sbyte> getFind
            (this TmphSubArray<sbyte> array, Func<sbyte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                return TmphArrayExtension.GetFind(array.Array, array.StartIndex, array.Count, isValue);
            }
            return default(TmphSubArray<sbyte>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static sbyte[] getFindArray
            (this TmphSubArray<sbyte> array, Func<sbyte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int length = ((array.Count + 31) >> 5) << 2;
                TmphMemoryPool pool = Laurent.Lee.CLB.TmphMemoryPool.GetDefaultPool(length);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return TmphArrayExtension.GetFindArray(array.Array, array.StartIndex, array.Count, isValue, new TmphFixedMap(dataFixed));
                    }
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<sbyte>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static sbyte[] getArray<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, sbyte> getValue)
        {
            if (TmphSubArray.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] array = TmphSubArray.Array;
                sbyte[] newValues = new sbyte[TmphSubArray.Count];
                fixed (sbyte* newValueFixed = newValues)
                {
                    sbyte* write = newValueFixed;
                    int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                    do
                    {
                        *write++ = getValue(array[index++]);
                    }
                    while (index != endIndex);
                }
                return newValues;
            }
            return TmphNullValue<sbyte>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static TValueType[] getArray<TValueType>
            (this TmphSubArray<sbyte> array, Func<sbyte, TValueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] newValues = new TValueType[array.Count];
                fixed (sbyte* arrayFixed = array.Array)
                {
                    sbyte* start = arrayFixed + array.StartIndex, end = start + array.Count;
                    int index = 0;
                    do
                    {
                        newValues[index++] = getValue(*start);
                    }
                    while (++start != end);
                }
                return newValues;
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static TmphSubArray<sbyte> each
            (this TmphSubArray<sbyte> array, Action<sbyte> method)
        {
            if (array.Count != 0)
            {
                if (method == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (sbyte* valueFixed = array.Array)
                {
                    for (sbyte* start = valueFixed + array.StartIndex, end = start + array.Count; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this TmphSubArray<sbyte> array, out sbyte value)
        {
            if (array.Count != 0)
            {
                fixed (sbyte* valueFixed = array.Array)
                {
                    sbyte* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static sbyte max(this TmphSubArray<sbyte> array, sbyte TmphNullValue)
        {
            sbyte value;
            return max(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, sbyte> getKey, out sbyte value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    sbyte nextKey = getKey(array[index]);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static sbyte maxKey<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, sbyte> getKey, sbyte TmphNullValue)
        {
            sbyte value;
            return maxKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, sbyte> getKey, out TValueType value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                sbyte maxKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    TValueType nextValue = array[index];
                    sbyte nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, sbyte> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return max(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this TmphSubArray<sbyte> array, out sbyte value)
        {
            if (array.Count != 0)
            {
                fixed (sbyte* valueFixed = array.Array)
                {
                    sbyte* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static sbyte min(this TmphSubArray<sbyte> array, sbyte TmphNullValue)
        {
            sbyte value;
            return min(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, sbyte> getKey, out sbyte value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    sbyte nextKey = getKey(array[index]);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static sbyte minKey<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, sbyte> getKey, sbyte TmphNullValue)
        {
            sbyte value;
            return minKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, sbyte> getKey, out TValueType value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                sbyte minKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    TValueType nextValue = array[index];
                    sbyte nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, sbyte> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return min(array, getKey, out value) ? value : TmphNullValue;
        }
    }
}

namespace Laurent.Lee.CLB.Unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void Move(sbyte[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (sbyte* valueFixed = array)
                {
                    for (sbyte* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (sbyte* valueFixed = array) Win32.TmphKernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(sbyte));
#endif
        }
    }
}
namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        public unsafe static void Reverse(double[] array, int index, int length)
        {
            fixed (double* valueFixed = array)
            {
                for (double* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    double value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static double[] reverse(this double[] array)
        {
            if (array == null || array.Length == 0) return TmphNullValue<double>.Array;
            Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        public unsafe static double[] GetReverse(double[] array, int index, int length)
        {
            double[] newValues = new double[length];
            fixed (double* valueFixed = array, newValueFixed = newValues)
            {
                for (double* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end;
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static double[] getReverse(this double[] array)
        {
            if (array == null || array.Length == 0) return TmphNullValue<double>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        public unsafe static double* IndexOf
            (double* valueFixed, int length, double value)
        {
            for (double* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this double[] array, double value)
        {
            if (array != null)
            {
                fixed (double* valueFixed = array)
                {
                    double* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        public unsafe static double* IndexOf
            (double* valueFixed, int length, Func<double, bool> isValue)
        {
            for (double* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this double[] array, Func<double, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (double* valueFixed = array)
                {
                    double* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(double)</returns>
        public unsafe static double firstOrDefault
            (this double[] array, Func<double, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (double* valueFixed = array)
                {
                    double* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(double);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this double[] array, Func<double, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int value = 0;
                fixed (double* valueFixed = array)
                {
                    for (double* end = valueFixed + array.Length; end != valueFixed; )
                    {
                        if (isValue(*--end)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static double[] replaceFirst
            (this double[] array, double value, Func<double, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (double* valueFixed = array)
                {
                    double* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return TmphNullValue<double>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static double[] getArray<TValueType>
            (this TValueType[] array, Func<TValueType, double> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                double[] newValues = new double[array.Length];
                fixed (double* newValueFixed = newValues)
                {
                    double* writeValue = newValueFixed;
                    foreach (TValueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return TmphNullValue<double>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<double> GetFind
            (this double[] array, int index, int length, Func<double, bool> isValue)
        {
            double[] newValues = new double[length < sizeof(int) ? sizeof(int) : length];
            fixed (double* newValueFixed = newValues, valueFixed = array)
            {
                double* write = newValueFixed;
                for (double* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return TmphSubArray<double>.Unsafe(newValues, 0, (int)(write - newValueFixed));
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<double> getFind
            (this double[] array, Func<double, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                return GetFind(array, 0, array.Length, isValue);
            }
            return default(TmphSubArray<double>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static double[] getFindArray
            (this double[] array, Func<double, bool> isValue)
        {
            if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                TmphMemoryPool pool = Laurent.Lee.CLB.TmphMemoryPool.GetDefaultPool(length = ((length + 31) >> 5) << 2);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return GetFindArray(array, 0, array.Length, isValue, new TmphFixedMap(dataFixed));
                    }
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<double>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        public unsafe static double[] GetFindArray
            (double[] array, int index, int count, Func<double, bool> isValue, TmphFixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (double* valueFixed = array)
            {
                double* startFixed = valueFixed + index, end = startFixed + count;
                for (double* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    double[] newValues = new double[length];
                    fixed (double* newValueFixed = newValues)
                    {
                        double* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return TmphNullValue<double>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this double[] array, out double value)
        {
            if (array.length() != 0)
            {
                fixed (double* valueFixed = array)
                {
                    value = *valueFixed;
                    for (double* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static double max(this double[] array, double TmphNullValue)
        {
            double value;
            return max(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this TValueType[] array, Func<TValueType, double> getKey, out double value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (TValueType nextValue in array)
                {
                    double nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static double maxKey<TValueType>
            (this TValueType[] array, Func<TValueType, double> getKey, double TmphNullValue)
        {
            double value;
            return maxKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this TValueType[] array, Func<TValueType, double> getKey, out TValueType value)
        {
            if (array.length() != 0)
            {
                double maxKey = getKey(value = array[0]);
                foreach (TValueType nextValue in array)
                {
                    double nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>(this TValueType[] array, Func<TValueType, double> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return max(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this double[] array, out double value)
        {
            if (array.length() != 0)
            {
                fixed (double* valueFixed = array)
                {
                    value = *valueFixed;
                    for (double* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = double.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static double min(this double[] array, double TmphNullValue)
        {
            double value;
            return min(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this TValueType[] array, Func<TValueType, double> getKey, out double value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (TValueType nextValue in array)
                {
                    double nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = double.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static double minKey<TValueType>
            (this TValueType[] array, Func<TValueType, double> getKey, double TmphNullValue)
        {
            double value;
            return minKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>(this TValueType[] array, Func<TValueType, double> getKey, out TValueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                double minKey = getKey(value);
                foreach (TValueType nextValue in array)
                {
                    double nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>(this TValueType[] array, Func<TValueType, double> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return min(array, getKey, out value) ? value : TmphNullValue;
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static double[] getReverse(this TmphSubArray<double> array)
        {
            if (array.Count == 0) return TmphNullValue<double>.Array;
            return TmphArrayExtension.GetReverse(array.Array, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static TmphSubArray<double> reverse(this TmphSubArray<double> array)
        {
            if (array.Count > 1) TmphArrayExtension.Reverse(array.Array, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this TmphSubArray<double> array, double value)
        {
            if (array.Count != 0)
            {
                fixed (double* valueFixed = array.Array)
                {
                    double* start = valueFixed + array.StartIndex, index = TmphArrayExtension.IndexOf(start, array.Count, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this TmphSubArray<double> array, Func<double, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (double* valueFixed = array.Array)
                {
                    double* start = valueFixed + array.StartIndex, index = TmphArrayExtension.IndexOf(start, array.Count, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(double)</returns>
        public unsafe static double firstOrDefault
            (this TmphSubArray<double> array, Func<double, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Count)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (double* valueFixed = array.Array)
                {
                    double* valueIndex = TmphArrayExtension.IndexOf(valueFixed + array.StartIndex + index, array.Count - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(double);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count(this TmphSubArray<double> array, Func<double, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int value = 0;
                fixed (double* valueFixed = array.Array)
                {
                    double* start = valueFixed + array.StartIndex, end = start + array.Count;
                    do
                    {
                        if (isValue(*start)) ++value;
                    }
                    while (++start != end);
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static TmphSubArray<double> replaceFirst
            (this TmphSubArray<double> array, double value, Func<double, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (double* valueFixed = array.Array)
                {
                    double* valueIndex = TmphArrayExtension.IndexOf(valueFixed + array.StartIndex, array.Count, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<double> find
            (this TmphSubArray<double> array, Func<double, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (double* valueFixed = array.Array)
                {
                    double* write = valueFixed + array.StartIndex, start = write, end = write + array.Count;
                    do
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    while (++start != end);
                    return TmphSubArray<double>.Unsafe(array.Array, array.StartIndex, (int)(write - valueFixed) - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<double> getFind
            (this TmphSubArray<double> array, Func<double, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                return TmphArrayExtension.GetFind(array.Array, array.StartIndex, array.Count, isValue);
            }
            return default(TmphSubArray<double>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static double[] getFindArray
            (this TmphSubArray<double> array, Func<double, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int length = ((array.Count + 31) >> 5) << 2;
                TmphMemoryPool pool = Laurent.Lee.CLB.TmphMemoryPool.GetDefaultPool(length);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return TmphArrayExtension.GetFindArray(array.Array, array.StartIndex, array.Count, isValue, new TmphFixedMap(dataFixed));
                    }
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<double>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static double[] getArray<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, double> getValue)
        {
            if (TmphSubArray.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] array = TmphSubArray.Array;
                double[] newValues = new double[TmphSubArray.Count];
                fixed (double* newValueFixed = newValues)
                {
                    double* write = newValueFixed;
                    int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                    do
                    {
                        *write++ = getValue(array[index++]);
                    }
                    while (index != endIndex);
                }
                return newValues;
            }
            return TmphNullValue<double>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static TValueType[] getArray<TValueType>
            (this TmphSubArray<double> array, Func<double, TValueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] newValues = new TValueType[array.Count];
                fixed (double* arrayFixed = array.Array)
                {
                    double* start = arrayFixed + array.StartIndex, end = start + array.Count;
                    int index = 0;
                    do
                    {
                        newValues[index++] = getValue(*start);
                    }
                    while (++start != end);
                }
                return newValues;
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static TmphSubArray<double> each
            (this TmphSubArray<double> array, Action<double> method)
        {
            if (array.Count != 0)
            {
                if (method == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (double* valueFixed = array.Array)
                {
                    for (double* start = valueFixed + array.StartIndex, end = start + array.Count; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this TmphSubArray<double> array, out double value)
        {
            if (array.Count != 0)
            {
                fixed (double* valueFixed = array.Array)
                {
                    double* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static double max(this TmphSubArray<double> array, double TmphNullValue)
        {
            double value;
            return max(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, double> getKey, out double value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    double nextKey = getKey(array[index]);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static double maxKey<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, double> getKey, double TmphNullValue)
        {
            double value;
            return maxKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, double> getKey, out TValueType value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                double maxKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    TValueType nextValue = array[index];
                    double nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, double> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return max(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this TmphSubArray<double> array, out double value)
        {
            if (array.Count != 0)
            {
                fixed (double* valueFixed = array.Array)
                {
                    double* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static double min(this TmphSubArray<double> array, double TmphNullValue)
        {
            double value;
            return min(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, double> getKey, out double value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    double nextKey = getKey(array[index]);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static double minKey<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, double> getKey, double TmphNullValue)
        {
            double value;
            return minKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, double> getKey, out TValueType value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                double minKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    TValueType nextValue = array[index];
                    double nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, double> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return min(array, getKey, out value) ? value : TmphNullValue;
        }
    }
}

namespace Laurent.Lee.CLB.Unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void Move(double[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (double* valueFixed = array)
                {
                    for (double* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (double* valueFixed = array) Win32.TmphKernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(double));
#endif
        }
    }
}
namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        public unsafe static void Reverse(float[] array, int index, int length)
        {
            fixed (float* valueFixed = array)
            {
                for (float* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    float value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static float[] reverse(this float[] array)
        {
            if (array == null || array.Length == 0) return TmphNullValue<float>.Array;
            Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        public unsafe static float[] GetReverse(float[] array, int index, int length)
        {
            float[] newValues = new float[length];
            fixed (float* valueFixed = array, newValueFixed = newValues)
            {
                for (float* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end;
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static float[] getReverse(this float[] array)
        {
            if (array == null || array.Length == 0) return TmphNullValue<float>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        public unsafe static float* IndexOf
            (float* valueFixed, int length, float value)
        {
            for (float* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this float[] array, float value)
        {
            if (array != null)
            {
                fixed (float* valueFixed = array)
                {
                    float* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        public unsafe static float* IndexOf
            (float* valueFixed, int length, Func<float, bool> isValue)
        {
            for (float* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this float[] array, Func<float, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (float* valueFixed = array)
                {
                    float* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(float)</returns>
        public unsafe static float firstOrDefault
            (this float[] array, Func<float, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (float* valueFixed = array)
                {
                    float* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(float);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this float[] array, Func<float, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int value = 0;
                fixed (float* valueFixed = array)
                {
                    for (float* end = valueFixed + array.Length; end != valueFixed; )
                    {
                        if (isValue(*--end)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static float[] replaceFirst
            (this float[] array, float value, Func<float, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (float* valueFixed = array)
                {
                    float* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return TmphNullValue<float>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static float[] getArray<TValueType>
            (this TValueType[] array, Func<TValueType, float> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                float[] newValues = new float[array.Length];
                fixed (float* newValueFixed = newValues)
                {
                    float* writeValue = newValueFixed;
                    foreach (TValueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return TmphNullValue<float>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<float> GetFind
            (this float[] array, int index, int length, Func<float, bool> isValue)
        {
            float[] newValues = new float[length < sizeof(int) ? sizeof(int) : length];
            fixed (float* newValueFixed = newValues, valueFixed = array)
            {
                float* write = newValueFixed;
                for (float* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return TmphSubArray<float>.Unsafe(newValues, 0, (int)(write - newValueFixed));
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<float> getFind
            (this float[] array, Func<float, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                return GetFind(array, 0, array.Length, isValue);
            }
            return default(TmphSubArray<float>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static float[] getFindArray
            (this float[] array, Func<float, bool> isValue)
        {
            if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                TmphMemoryPool pool = Laurent.Lee.CLB.TmphMemoryPool.GetDefaultPool(length = ((length + 31) >> 5) << 2);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return GetFindArray(array, 0, array.Length, isValue, new TmphFixedMap(dataFixed));
                    }
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<float>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        public unsafe static float[] GetFindArray
            (float[] array, int index, int count, Func<float, bool> isValue, TmphFixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (float* valueFixed = array)
            {
                float* startFixed = valueFixed + index, end = startFixed + count;
                for (float* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    float[] newValues = new float[length];
                    fixed (float* newValueFixed = newValues)
                    {
                        float* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return TmphNullValue<float>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this float[] array, out float value)
        {
            if (array.length() != 0)
            {
                fixed (float* valueFixed = array)
                {
                    value = *valueFixed;
                    for (float* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static float max(this float[] array, float TmphNullValue)
        {
            float value;
            return max(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this TValueType[] array, Func<TValueType, float> getKey, out float value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (TValueType nextValue in array)
                {
                    float nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static float maxKey<TValueType>
            (this TValueType[] array, Func<TValueType, float> getKey, float TmphNullValue)
        {
            float value;
            return maxKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this TValueType[] array, Func<TValueType, float> getKey, out TValueType value)
        {
            if (array.length() != 0)
            {
                float maxKey = getKey(value = array[0]);
                foreach (TValueType nextValue in array)
                {
                    float nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>(this TValueType[] array, Func<TValueType, float> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return max(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this float[] array, out float value)
        {
            if (array.length() != 0)
            {
                fixed (float* valueFixed = array)
                {
                    value = *valueFixed;
                    for (float* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = float.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static float min(this float[] array, float TmphNullValue)
        {
            float value;
            return min(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this TValueType[] array, Func<TValueType, float> getKey, out float value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (TValueType nextValue in array)
                {
                    float nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = float.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static float minKey<TValueType>
            (this TValueType[] array, Func<TValueType, float> getKey, float TmphNullValue)
        {
            float value;
            return minKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>(this TValueType[] array, Func<TValueType, float> getKey, out TValueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                float minKey = getKey(value);
                foreach (TValueType nextValue in array)
                {
                    float nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>(this TValueType[] array, Func<TValueType, float> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return min(array, getKey, out value) ? value : TmphNullValue;
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static float[] getReverse(this TmphSubArray<float> array)
        {
            if (array.Count == 0) return TmphNullValue<float>.Array;
            return TmphArrayExtension.GetReverse(array.Array, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static TmphSubArray<float> reverse(this TmphSubArray<float> array)
        {
            if (array.Count > 1) TmphArrayExtension.Reverse(array.Array, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this TmphSubArray<float> array, float value)
        {
            if (array.Count != 0)
            {
                fixed (float* valueFixed = array.Array)
                {
                    float* start = valueFixed + array.StartIndex, index = TmphArrayExtension.IndexOf(start, array.Count, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this TmphSubArray<float> array, Func<float, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (float* valueFixed = array.Array)
                {
                    float* start = valueFixed + array.StartIndex, index = TmphArrayExtension.IndexOf(start, array.Count, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(float)</returns>
        public unsafe static float firstOrDefault
            (this TmphSubArray<float> array, Func<float, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Count)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (float* valueFixed = array.Array)
                {
                    float* valueIndex = TmphArrayExtension.IndexOf(valueFixed + array.StartIndex + index, array.Count - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(float);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count(this TmphSubArray<float> array, Func<float, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int value = 0;
                fixed (float* valueFixed = array.Array)
                {
                    float* start = valueFixed + array.StartIndex, end = start + array.Count;
                    do
                    {
                        if (isValue(*start)) ++value;
                    }
                    while (++start != end);
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static TmphSubArray<float> replaceFirst
            (this TmphSubArray<float> array, float value, Func<float, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (float* valueFixed = array.Array)
                {
                    float* valueIndex = TmphArrayExtension.IndexOf(valueFixed + array.StartIndex, array.Count, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<float> find
            (this TmphSubArray<float> array, Func<float, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (float* valueFixed = array.Array)
                {
                    float* write = valueFixed + array.StartIndex, start = write, end = write + array.Count;
                    do
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    while (++start != end);
                    return TmphSubArray<float>.Unsafe(array.Array, array.StartIndex, (int)(write - valueFixed) - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<float> getFind
            (this TmphSubArray<float> array, Func<float, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                return TmphArrayExtension.GetFind(array.Array, array.StartIndex, array.Count, isValue);
            }
            return default(TmphSubArray<float>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static float[] getFindArray
            (this TmphSubArray<float> array, Func<float, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int length = ((array.Count + 31) >> 5) << 2;
                TmphMemoryPool pool = Laurent.Lee.CLB.TmphMemoryPool.GetDefaultPool(length);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return TmphArrayExtension.GetFindArray(array.Array, array.StartIndex, array.Count, isValue, new TmphFixedMap(dataFixed));
                    }
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<float>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static float[] getArray<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, float> getValue)
        {
            if (TmphSubArray.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] array = TmphSubArray.Array;
                float[] newValues = new float[TmphSubArray.Count];
                fixed (float* newValueFixed = newValues)
                {
                    float* write = newValueFixed;
                    int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                    do
                    {
                        *write++ = getValue(array[index++]);
                    }
                    while (index != endIndex);
                }
                return newValues;
            }
            return TmphNullValue<float>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static TValueType[] getArray<TValueType>
            (this TmphSubArray<float> array, Func<float, TValueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] newValues = new TValueType[array.Count];
                fixed (float* arrayFixed = array.Array)
                {
                    float* start = arrayFixed + array.StartIndex, end = start + array.Count;
                    int index = 0;
                    do
                    {
                        newValues[index++] = getValue(*start);
                    }
                    while (++start != end);
                }
                return newValues;
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static TmphSubArray<float> each
            (this TmphSubArray<float> array, Action<float> method)
        {
            if (array.Count != 0)
            {
                if (method == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (float* valueFixed = array.Array)
                {
                    for (float* start = valueFixed + array.StartIndex, end = start + array.Count; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this TmphSubArray<float> array, out float value)
        {
            if (array.Count != 0)
            {
                fixed (float* valueFixed = array.Array)
                {
                    float* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static float max(this TmphSubArray<float> array, float TmphNullValue)
        {
            float value;
            return max(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, float> getKey, out float value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    float nextKey = getKey(array[index]);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static float maxKey<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, float> getKey, float TmphNullValue)
        {
            float value;
            return maxKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, float> getKey, out TValueType value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                float maxKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    TValueType nextValue = array[index];
                    float nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, float> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return max(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this TmphSubArray<float> array, out float value)
        {
            if (array.Count != 0)
            {
                fixed (float* valueFixed = array.Array)
                {
                    float* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static float min(this TmphSubArray<float> array, float TmphNullValue)
        {
            float value;
            return min(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, float> getKey, out float value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    float nextKey = getKey(array[index]);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static float minKey<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, float> getKey, float TmphNullValue)
        {
            float value;
            return minKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, float> getKey, out TValueType value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                float minKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    TValueType nextValue = array[index];
                    float nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, float> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return min(array, getKey, out value) ? value : TmphNullValue;
        }
    }
}

namespace Laurent.Lee.CLB.Unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void Move(float[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (float* valueFixed = array)
                {
                    for (float* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (float* valueFixed = array) Win32.TmphKernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(float));
#endif
        }
    }
}
namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        public unsafe static void Reverse(DateTime[] array, int index, int length)
        {
            fixed (DateTime* valueFixed = array)
            {
                for (DateTime* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    DateTime value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static DateTime[] reverse(this DateTime[] array)
        {
            if (array == null || array.Length == 0) return TmphNullValue<DateTime>.Array;
            Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        public unsafe static DateTime[] GetReverse(DateTime[] array, int index, int length)
        {
            DateTime[] newValues = new DateTime[length];
            fixed (DateTime* valueFixed = array, newValueFixed = newValues)
            {
                for (DateTime* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end;
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static DateTime[] getReverse(this DateTime[] array)
        {
            if (array == null || array.Length == 0) return TmphNullValue<DateTime>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        public unsafe static DateTime* IndexOf
            (DateTime* valueFixed, int length, DateTime value)
        {
            for (DateTime* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this DateTime[] array, DateTime value)
        {
            if (array != null)
            {
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="values">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        public unsafe static DateTime* IndexOf
            (DateTime* valueFixed, int length, Func<DateTime, bool> isValue)
        {
            for (DateTime* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this DateTime[] array, Func<DateTime, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(DateTime)</returns>
        public unsafe static DateTime firstOrDefault
            (this DateTime[] array, Func<DateTime, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(DateTime);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this DateTime[] array, Func<DateTime, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int value = 0;
                fixed (DateTime* valueFixed = array)
                {
                    for (DateTime* end = valueFixed + array.Length; end != valueFixed; )
                    {
                        if (isValue(*--end)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static DateTime[] replaceFirst
            (this DateTime[] array, DateTime value, Func<DateTime, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return TmphNullValue<DateTime>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static DateTime[] getArray<TValueType>
            (this TValueType[] array, Func<TValueType, DateTime> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                DateTime[] newValues = new DateTime[array.Length];
                fixed (DateTime* newValueFixed = newValues)
                {
                    DateTime* writeValue = newValueFixed;
                    foreach (TValueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return TmphNullValue<DateTime>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<DateTime> GetFind
            (this DateTime[] array, int index, int length, Func<DateTime, bool> isValue)
        {
            DateTime[] newValues = new DateTime[length < sizeof(int) ? sizeof(int) : length];
            fixed (DateTime* newValueFixed = newValues, valueFixed = array)
            {
                DateTime* write = newValueFixed;
                for (DateTime* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return TmphSubArray<DateTime>.Unsafe(newValues, 0, (int)(write - newValueFixed));
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<DateTime> getFind
            (this DateTime[] array, Func<DateTime, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                return GetFind(array, 0, array.Length, isValue);
            }
            return default(TmphSubArray<DateTime>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static DateTime[] getFindArray
            (this DateTime[] array, Func<DateTime, bool> isValue)
        {
            if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                TmphMemoryPool pool = Laurent.Lee.CLB.TmphMemoryPool.GetDefaultPool(length = ((length + 31) >> 5) << 2);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return GetFindArray(array, 0, array.Length, isValue, new TmphFixedMap(dataFixed));
                    }
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<DateTime>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        public unsafe static DateTime[] GetFindArray
            (DateTime[] array, int index, int count, Func<DateTime, bool> isValue, TmphFixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (DateTime* valueFixed = array)
            {
                DateTime* startFixed = valueFixed + index, end = startFixed + count;
                for (DateTime* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    DateTime[] newValues = new DateTime[length];
                    fixed (DateTime* newValueFixed = newValues)
                    {
                        DateTime* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return TmphNullValue<DateTime>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this DateTime[] array, out DateTime value)
        {
            if (array.length() != 0)
            {
                fixed (DateTime* valueFixed = array)
                {
                    value = *valueFixed;
                    for (DateTime* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static DateTime max(this DateTime[] array, DateTime TmphNullValue)
        {
            DateTime value;
            return max(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this TValueType[] array, Func<TValueType, DateTime> getKey, out DateTime value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (TValueType nextValue in array)
                {
                    DateTime nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static DateTime maxKey<TValueType>
            (this TValueType[] array, Func<TValueType, DateTime> getKey, DateTime TmphNullValue)
        {
            DateTime value;
            return maxKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this TValueType[] array, Func<TValueType, DateTime> getKey, out TValueType value)
        {
            if (array.length() != 0)
            {
                DateTime maxKey = getKey(value = array[0]);
                foreach (TValueType nextValue in array)
                {
                    DateTime nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>(this TValueType[] array, Func<TValueType, DateTime> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return max(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this DateTime[] array, out DateTime value)
        {
            if (array.length() != 0)
            {
                fixed (DateTime* valueFixed = array)
                {
                    value = *valueFixed;
                    for (DateTime* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = DateTime.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static DateTime min(this DateTime[] array, DateTime TmphNullValue)
        {
            DateTime value;
            return min(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this TValueType[] array, Func<TValueType, DateTime> getKey, out DateTime value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (TValueType nextValue in array)
                {
                    DateTime nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = DateTime.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static DateTime minKey<TValueType>
            (this TValueType[] array, Func<TValueType, DateTime> getKey, DateTime TmphNullValue)
        {
            DateTime value;
            return minKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>(this TValueType[] array, Func<TValueType, DateTime> getKey, out TValueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                DateTime minKey = getKey(value);
                foreach (TValueType nextValue in array)
                {
                    DateTime nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>(this TValueType[] array, Func<TValueType, DateTime> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return min(array, getKey, out value) ? value : TmphNullValue;
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static DateTime[] getReverse(this TmphSubArray<DateTime> array)
        {
            if (array.Count == 0) return TmphNullValue<DateTime>.Array;
            return TmphArrayExtension.GetReverse(array.Array, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        public static TmphSubArray<DateTime> reverse(this TmphSubArray<DateTime> array)
        {
            if (array.Count > 1) TmphArrayExtension.Reverse(array.Array, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this TmphSubArray<DateTime> array, DateTime value)
        {
            if (array.Count != 0)
            {
                fixed (DateTime* valueFixed = array.Array)
                {
                    DateTime* start = valueFixed + array.StartIndex, index = TmphArrayExtension.IndexOf(start, array.Count, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this TmphSubArray<DateTime> array, Func<DateTime, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (DateTime* valueFixed = array.Array)
                {
                    DateTime* start = valueFixed + array.StartIndex, index = TmphArrayExtension.IndexOf(start, array.Count, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(DateTime)</returns>
        public unsafe static DateTime firstOrDefault
            (this TmphSubArray<DateTime> array, Func<DateTime, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Count)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (DateTime* valueFixed = array.Array)
                {
                    DateTime* valueIndex = TmphArrayExtension.IndexOf(valueFixed + array.StartIndex + index, array.Count - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(DateTime);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count(this TmphSubArray<DateTime> array, Func<DateTime, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int value = 0;
                fixed (DateTime* valueFixed = array.Array)
                {
                    DateTime* start = valueFixed + array.StartIndex, end = start + array.Count;
                    do
                    {
                        if (isValue(*start)) ++value;
                    }
                    while (++start != end);
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static TmphSubArray<DateTime> replaceFirst
            (this TmphSubArray<DateTime> array, DateTime value, Func<DateTime, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (DateTime* valueFixed = array.Array)
                {
                    DateTime* valueIndex = TmphArrayExtension.IndexOf(valueFixed + array.StartIndex, array.Count, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<DateTime> find
            (this TmphSubArray<DateTime> array, Func<DateTime, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (DateTime* valueFixed = array.Array)
                {
                    DateTime* write = valueFixed + array.StartIndex, start = write, end = write + array.Count;
                    do
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    while (++start != end);
                    return TmphSubArray<DateTime>.Unsafe(array.Array, array.StartIndex, (int)(write - valueFixed) - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static TmphSubArray<DateTime> getFind
            (this TmphSubArray<DateTime> array, Func<DateTime, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                return TmphArrayExtension.GetFind(array.Array, array.StartIndex, array.Count, isValue);
            }
            return default(TmphSubArray<DateTime>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static DateTime[] getFindArray
            (this TmphSubArray<DateTime> array, Func<DateTime, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int length = ((array.Count + 31) >> 5) << 2;
                TmphMemoryPool pool = Laurent.Lee.CLB.TmphMemoryPool.GetDefaultPool(length);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return TmphArrayExtension.GetFindArray(array.Array, array.StartIndex, array.Count, isValue, new TmphFixedMap(dataFixed));
                    }
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<DateTime>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static DateTime[] getArray<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, DateTime> getValue)
        {
            if (TmphSubArray.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] array = TmphSubArray.Array;
                DateTime[] newValues = new DateTime[TmphSubArray.Count];
                fixed (DateTime* newValueFixed = newValues)
                {
                    DateTime* write = newValueFixed;
                    int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                    do
                    {
                        *write++ = getValue(array[index++]);
                    }
                    while (index != endIndex);
                }
                return newValues;
            }
            return TmphNullValue<DateTime>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static TValueType[] getArray<TValueType>
            (this TmphSubArray<DateTime> array, Func<DateTime, TValueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] newValues = new TValueType[array.Count];
                fixed (DateTime* arrayFixed = array.Array)
                {
                    DateTime* start = arrayFixed + array.StartIndex, end = start + array.Count;
                    int index = 0;
                    do
                    {
                        newValues[index++] = getValue(*start);
                    }
                    while (++start != end);
                }
                return newValues;
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static TmphSubArray<DateTime> each
            (this TmphSubArray<DateTime> array, Action<DateTime> method)
        {
            if (array.Count != 0)
            {
                if (method == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                fixed (DateTime* valueFixed = array.Array)
                {
                    for (DateTime* start = valueFixed + array.StartIndex, end = start + array.Count; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this TmphSubArray<DateTime> array, out DateTime value)
        {
            if (array.Count != 0)
            {
                fixed (DateTime* valueFixed = array.Array)
                {
                    DateTime* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public unsafe static DateTime max(this TmphSubArray<DateTime> array, DateTime TmphNullValue)
        {
            DateTime value;
            return max(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, DateTime> getKey, out DateTime value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    DateTime nextKey = getKey(array[index]);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static DateTime maxKey<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, DateTime> getKey, DateTime TmphNullValue)
        {
            DateTime value;
            return maxKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, DateTime> getKey, out TValueType value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                DateTime maxKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    TValueType nextValue = array[index];
                    DateTime nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, DateTime> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return max(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this TmphSubArray<DateTime> array, out DateTime value)
        {
            if (array.Count != 0)
            {
                fixed (DateTime* valueFixed = array.Array)
                {
                    DateTime* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public unsafe static DateTime min(this TmphSubArray<DateTime> array, DateTime TmphNullValue)
        {
            DateTime value;
            return min(array, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, DateTime> getKey, out DateTime value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    DateTime nextKey = getKey(array[index]);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static DateTime minKey<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, DateTime> getKey, DateTime TmphNullValue)
        {
            DateTime value;
            return minKey(array, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="TmphSubArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>
            (this TmphSubArray<TValueType> TmphSubArray, Func<TValueType, DateTime> getKey, out TValueType value)
        {
            if (TmphSubArray.Count != 0)
            {
                TValueType[] array = TmphSubArray.Array;
                int index = TmphSubArray.StartIndex, endIndex = index + TmphSubArray.Count;
                DateTime minKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    TValueType nextValue = array[index];
                    DateTime nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(TValueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="TmphNullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, DateTime> getKey, TValueType TmphNullValue)
        {
            TValueType value;
            return min(array, getKey, out value) ? value : TmphNullValue;
        }
    }
}

namespace Laurent.Lee.CLB.Unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
        public unsafe static void Move(DateTime[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (DateTime* valueFixed = array)
                {
                    for (DateTime* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (DateTime* valueFixed = array) Win32.TmphKernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(DateTime));
#endif
        }
    }
}
namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        public unsafe static TmphSubArray<long> distinct(this long[] array)
        {
            if (array == null) return default(TmphSubArray<long>);
            if (array.Length <= 1) return TmphSubArray<long>.Unsafe(array, 0, array.Length);
            TmphArrayExtension.sort(array, 0, array.Length);
            fixed (long* valueFixed = array)
            {
                long* start = valueFixed + 1, end = valueFixed + array.Length, write = valueFixed;
                do
                {
                    if (*start != *write) *++write = *start;
                }
                while (++start != end);
                return TmphSubArray<long>.Unsafe(array, 0, (int)(write - valueFixed) + 1);
            }
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static TValueType[] distinct<TValueType>
            (this long[] array, Func<long, TValueType> getValue)
        {
            return new TmphSubArray<long>(array).distinct(getValue);
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static TmphSubArray<long> distinct<TValueType>
            (this TValueType[] array, Func<TValueType, long> getValue)
        {
            if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
            long[] newValues = array.getArray(getValue);
            TmphArrayExtension.sort(newValues, 0, newValues.Length);
            return newValues.distinct();
        }
        /// <summary>
        /// 求交集
        /// </summary>
        /// <param name="left">左侧数据</param>
        /// <param name="right">右侧数据</param>
        /// <returns>数据交集</returns>
        public unsafe static TmphSubArray<long> intersect(this long[] left, long[] right)
        {
            int leftLength = left.length(), rightLength = right.length();
            if (leftLength != 0 && rightLength != 0)
            {
                long[] min = leftLength <= rightLength ? left : right, values = new long[min.Length];
                fixed (long* valueFixed = values)
                {
                    long* write = valueFixed;
                    TmphStaticHashSet<long> hash = new TmphStaticHashSet<long>(min);
                    foreach (long value in leftLength <= rightLength ? right : left)
                    {
                        if (hash.Contains(value)) *write++ = value;
                    }
                    return TmphSubArray<long>.Unsafe(values, 0, (int)(write - valueFixed));
                }
            }
            return default(TmphSubArray<long>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        public static TmphKeyValue<long, int>[] sortGroupCount(this long[] array)
        {
            return new TmphSubArray<long>(array).sortGroupCount();
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static TmphSubArray<TmphSubArray<TValueType>> sortGroup<TValueType>
            (this TValueType[] array, Func<TValueType, long> getValue)
        {
            return new TmphSubArray<TValueType>(array).sortGroup(getValue);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>数据排序分组数量</returns>
        public static int sortGroupCount<TValueType>
            (this TValueType[] array, Func<TValueType, long> getValue)
        {
            return new TmphSubArray<TValueType>(array).sortGroupCount(getValue);
        }
    }
    
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        public unsafe static TmphSubArray<long> distinct(this TmphSubArray<long> array)
        {
            if (array.Count > 1)
            {
                TmphArrayExtension.sort(array.Array, array.StartIndex, array.Count);
                fixed (long* valueFixed = array.Array)
                {
                    long* write = valueFixed + array.StartIndex, start = write + 1, end = write + array.Count;
                    do
                    {
                        if (*start != *write) *++write = *start;
                    }
                    while (++start != end);
                    return TmphSubArray<long>.Unsafe(array.Array, array.StartIndex, (int)(write - valueFixed) + 1 - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static TValueType[] distinct<TValueType>
            (this TmphSubArray<long> array, Func<long, TValueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TmphArrayExtension.sort(array.Array, array.StartIndex, array.Count);
                fixed (long* valueFixed = array.Array)
                {
                    long* start = valueFixed + array.StartIndex, end = start + array.Count;
                    long value = *start;
                    int count = 1;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            ++count;
                            value = *start;
                        }
                    }
                    TValueType[] values = new TValueType[count];
                    values[0] = getValue(value = *(start = valueFixed + array.StartIndex));
                    count = 1;
                    while (++start != end)
                    {
                        if (*start != value) values[count++] = getValue(value = *start);
                    }
                    return values;
                }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static TmphSubArray<long> distinct<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, long> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                long[] newValues = array.getArray(getValue);
                TmphArrayExtension.sort(newValues, 0, newValues.Length);
                return newValues.distinct();
            }
            return default(TmphSubArray<long>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        public unsafe static TmphKeyValue<long, int>[] sortGroupCount(this TmphSubArray<long> array)
        {
            if (array.Count != 0)
            {
                TmphArrayExtension.sort(array.Array, array.StartIndex, array.Count);
                fixed (long* valueFixed = array.Array)
                {
                    long* start = valueFixed + array.StartIndex, lastStart = start, end = start + array.Count;
                    long value = *start;
                    int count = 1;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            ++count;
                            value = *start;
                        }
                    }
                    TmphKeyValue<long, int>[] values = new TmphKeyValue<long, int>[count];
                    value = *(start = lastStart);
                    count = 0;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            values[count++].Set(value, (int)(start - lastStart));
                            value = *start;
                            lastStart = start;
                        }
                    }
                    values[count].Set(value, (int)(start - lastStart));
                    return values;
                }
            }
            return TmphNullValue<TmphKeyValue<long, int>>.Array;
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static TmphSubArray<TmphSubArray<TValueType>> sortGroup<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, long> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] sortArray = TmphArrayExtension.getSort(array.Array, getValue, array.StartIndex, array.Count);
                TmphSubArray<TValueType>[] values = new TmphSubArray<TValueType>[sortArray.Length];
                long key = getValue(sortArray[0]);
                int startIndex = 0, valueIndex = 0;
                for (int index = 1; index != sortArray.Length; ++index)
                {
                    long nextKey = getValue(sortArray[index]);
                    if (key != nextKey)
                    {
                        values[valueIndex++].UnsafeSet(sortArray, startIndex, index - startIndex);
                        key = nextKey;
                        startIndex = index;
                    }
                }
                values[valueIndex++].UnsafeSet(sortArray, startIndex, sortArray.Length - startIndex);
                return TmphSubArray<TmphSubArray<TValueType>>.Unsafe(values, 0, valueIndex);
            }
            return default(TmphSubArray<TmphSubArray<TValueType>>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合数量</returns>
        public unsafe static int sortGroupCount<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, long> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] sortArray = TmphArrayExtension.getSort(array.Array, getValue, array.StartIndex, array.Count);
                long key = getValue(sortArray[0]);
                int count = 0;
                for (int index = 1; index != sortArray.Length; ++index)
                {
                    long nextKey = getValue(sortArray[index]);
                    if (key != nextKey)
                    {
                        ++count;
                        key = nextKey;
                    }
                }
                return count + 1;
            }
            return 0;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        public unsafe static TmphSubArray<uint> distinct(this uint[] array)
        {
            if (array == null) return default(TmphSubArray<uint>);
            if (array.Length <= 1) return TmphSubArray<uint>.Unsafe(array, 0, array.Length);
            TmphArrayExtension.sort(array, 0, array.Length);
            fixed (uint* valueFixed = array)
            {
                uint* start = valueFixed + 1, end = valueFixed + array.Length, write = valueFixed;
                do
                {
                    if (*start != *write) *++write = *start;
                }
                while (++start != end);
                return TmphSubArray<uint>.Unsafe(array, 0, (int)(write - valueFixed) + 1);
            }
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static TValueType[] distinct<TValueType>
            (this uint[] array, Func<uint, TValueType> getValue)
        {
            return new TmphSubArray<uint>(array).distinct(getValue);
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static TmphSubArray<uint> distinct<TValueType>
            (this TValueType[] array, Func<TValueType, uint> getValue)
        {
            if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
            uint[] newValues = array.getArray(getValue);
            TmphArrayExtension.sort(newValues, 0, newValues.Length);
            return newValues.distinct();
        }
        /// <summary>
        /// 求交集
        /// </summary>
        /// <param name="left">左侧数据</param>
        /// <param name="right">右侧数据</param>
        /// <returns>数据交集</returns>
        public unsafe static TmphSubArray<uint> intersect(this uint[] left, uint[] right)
        {
            int leftLength = left.length(), rightLength = right.length();
            if (leftLength != 0 && rightLength != 0)
            {
                uint[] min = leftLength <= rightLength ? left : right, values = new uint[min.Length];
                fixed (uint* valueFixed = values)
                {
                    uint* write = valueFixed;
                    TmphStaticHashSet<uint> hash = new TmphStaticHashSet<uint>(min);
                    foreach (uint value in leftLength <= rightLength ? right : left)
                    {
                        if (hash.Contains(value)) *write++ = value;
                    }
                    return TmphSubArray<uint>.Unsafe(values, 0, (int)(write - valueFixed));
                }
            }
            return default(TmphSubArray<uint>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        public static TmphKeyValue<uint, int>[] sortGroupCount(this uint[] array)
        {
            return new TmphSubArray<uint>(array).sortGroupCount();
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static TmphSubArray<TmphSubArray<TValueType>> sortGroup<TValueType>
            (this TValueType[] array, Func<TValueType, uint> getValue)
        {
            return new TmphSubArray<TValueType>(array).sortGroup(getValue);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>数据排序分组数量</returns>
        public static int sortGroupCount<TValueType>
            (this TValueType[] array, Func<TValueType, uint> getValue)
        {
            return new TmphSubArray<TValueType>(array).sortGroupCount(getValue);
        }
    }
    
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        public unsafe static TmphSubArray<uint> distinct(this TmphSubArray<uint> array)
        {
            if (array.Count > 1)
            {
                TmphArrayExtension.sort(array.Array, array.StartIndex, array.Count);
                fixed (uint* valueFixed = array.Array)
                {
                    uint* write = valueFixed + array.StartIndex, start = write + 1, end = write + array.Count;
                    do
                    {
                        if (*start != *write) *++write = *start;
                    }
                    while (++start != end);
                    return TmphSubArray<uint>.Unsafe(array.Array, array.StartIndex, (int)(write - valueFixed) + 1 - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static TValueType[] distinct<TValueType>
            (this TmphSubArray<uint> array, Func<uint, TValueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TmphArrayExtension.sort(array.Array, array.StartIndex, array.Count);
                fixed (uint* valueFixed = array.Array)
                {
                    uint* start = valueFixed + array.StartIndex, end = start + array.Count;
                    uint value = *start;
                    int count = 1;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            ++count;
                            value = *start;
                        }
                    }
                    TValueType[] values = new TValueType[count];
                    values[0] = getValue(value = *(start = valueFixed + array.StartIndex));
                    count = 1;
                    while (++start != end)
                    {
                        if (*start != value) values[count++] = getValue(value = *start);
                    }
                    return values;
                }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static TmphSubArray<uint> distinct<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, uint> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                uint[] newValues = array.getArray(getValue);
                TmphArrayExtension.sort(newValues, 0, newValues.Length);
                return newValues.distinct();
            }
            return default(TmphSubArray<uint>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        public unsafe static TmphKeyValue<uint, int>[] sortGroupCount(this TmphSubArray<uint> array)
        {
            if (array.Count != 0)
            {
                TmphArrayExtension.sort(array.Array, array.StartIndex, array.Count);
                fixed (uint* valueFixed = array.Array)
                {
                    uint* start = valueFixed + array.StartIndex, lastStart = start, end = start + array.Count;
                    uint value = *start;
                    int count = 1;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            ++count;
                            value = *start;
                        }
                    }
                    TmphKeyValue<uint, int>[] values = new TmphKeyValue<uint, int>[count];
                    value = *(start = lastStart);
                    count = 0;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            values[count++].Set(value, (int)(start - lastStart));
                            value = *start;
                            lastStart = start;
                        }
                    }
                    values[count].Set(value, (int)(start - lastStart));
                    return values;
                }
            }
            return TmphNullValue<TmphKeyValue<uint, int>>.Array;
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static TmphSubArray<TmphSubArray<TValueType>> sortGroup<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, uint> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] sortArray = TmphArrayExtension.getSort(array.Array, getValue, array.StartIndex, array.Count);
                TmphSubArray<TValueType>[] values = new TmphSubArray<TValueType>[sortArray.Length];
                uint key = getValue(sortArray[0]);
                int startIndex = 0, valueIndex = 0;
                for (int index = 1; index != sortArray.Length; ++index)
                {
                    uint nextKey = getValue(sortArray[index]);
                    if (key != nextKey)
                    {
                        values[valueIndex++].UnsafeSet(sortArray, startIndex, index - startIndex);
                        key = nextKey;
                        startIndex = index;
                    }
                }
                values[valueIndex++].UnsafeSet(sortArray, startIndex, sortArray.Length - startIndex);
                return TmphSubArray<TmphSubArray<TValueType>>.Unsafe(values, 0, valueIndex);
            }
            return default(TmphSubArray<TmphSubArray<TValueType>>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合数量</returns>
        public unsafe static int sortGroupCount<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, uint> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] sortArray = TmphArrayExtension.getSort(array.Array, getValue, array.StartIndex, array.Count);
                uint key = getValue(sortArray[0]);
                int count = 0;
                for (int index = 1; index != sortArray.Length; ++index)
                {
                    uint nextKey = getValue(sortArray[index]);
                    if (key != nextKey)
                    {
                        ++count;
                        key = nextKey;
                    }
                }
                return count + 1;
            }
            return 0;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        public unsafe static TmphSubArray<int> distinct(this int[] array)
        {
            if (array == null) return default(TmphSubArray<int>);
            if (array.Length <= 1) return TmphSubArray<int>.Unsafe(array, 0, array.Length);
            TmphArrayExtension.sort(array, 0, array.Length);
            fixed (int* valueFixed = array)
            {
                int* start = valueFixed + 1, end = valueFixed + array.Length, write = valueFixed;
                do
                {
                    if (*start != *write) *++write = *start;
                }
                while (++start != end);
                return TmphSubArray<int>.Unsafe(array, 0, (int)(write - valueFixed) + 1);
            }
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static TValueType[] distinct<TValueType>
            (this int[] array, Func<int, TValueType> getValue)
        {
            return new TmphSubArray<int>(array).distinct(getValue);
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static TmphSubArray<int> distinct<TValueType>
            (this TValueType[] array, Func<TValueType, int> getValue)
        {
            if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
            int[] newValues = array.getArray(getValue);
            TmphArrayExtension.sort(newValues, 0, newValues.Length);
            return newValues.distinct();
        }
        /// <summary>
        /// 求交集
        /// </summary>
        /// <param name="left">左侧数据</param>
        /// <param name="right">右侧数据</param>
        /// <returns>数据交集</returns>
        public unsafe static TmphSubArray<int> intersect(this int[] left, int[] right)
        {
            int leftLength = left.length(), rightLength = right.length();
            if (leftLength != 0 && rightLength != 0)
            {
                int[] min = leftLength <= rightLength ? left : right, values = new int[min.Length];
                fixed (int* valueFixed = values)
                {
                    int* write = valueFixed;
                    TmphStaticHashSet<int> hash = new TmphStaticHashSet<int>(min);
                    foreach (int value in leftLength <= rightLength ? right : left)
                    {
                        if (hash.Contains(value)) *write++ = value;
                    }
                    return TmphSubArray<int>.Unsafe(values, 0, (int)(write - valueFixed));
                }
            }
            return default(TmphSubArray<int>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        public static TmphKeyValue<int, int>[] sortGroupCount(this int[] array)
        {
            return new TmphSubArray<int>(array).sortGroupCount();
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static TmphSubArray<TmphSubArray<TValueType>> sortGroup<TValueType>
            (this TValueType[] array, Func<TValueType, int> getValue)
        {
            return new TmphSubArray<TValueType>(array).sortGroup(getValue);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>数据排序分组数量</returns>
        public static int sortGroupCount<TValueType>
            (this TValueType[] array, Func<TValueType, int> getValue)
        {
            return new TmphSubArray<TValueType>(array).sortGroupCount(getValue);
        }
    }
    
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        public unsafe static TmphSubArray<int> distinct(this TmphSubArray<int> array)
        {
            if (array.Count > 1)
            {
                TmphArrayExtension.sort(array.Array, array.StartIndex, array.Count);
                fixed (int* valueFixed = array.Array)
                {
                    int* write = valueFixed + array.StartIndex, start = write + 1, end = write + array.Count;
                    do
                    {
                        if (*start != *write) *++write = *start;
                    }
                    while (++start != end);
                    return TmphSubArray<int>.Unsafe(array.Array, array.StartIndex, (int)(write - valueFixed) + 1 - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static TValueType[] distinct<TValueType>
            (this TmphSubArray<int> array, Func<int, TValueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TmphArrayExtension.sort(array.Array, array.StartIndex, array.Count);
                fixed (int* valueFixed = array.Array)
                {
                    int* start = valueFixed + array.StartIndex, end = start + array.Count;
                    int value = *start;
                    int count = 1;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            ++count;
                            value = *start;
                        }
                    }
                    TValueType[] values = new TValueType[count];
                    values[0] = getValue(value = *(start = valueFixed + array.StartIndex));
                    count = 1;
                    while (++start != end)
                    {
                        if (*start != value) values[count++] = getValue(value = *start);
                    }
                    return values;
                }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static TmphSubArray<int> distinct<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, int> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int[] newValues = array.getArray(getValue);
                TmphArrayExtension.sort(newValues, 0, newValues.Length);
                return newValues.distinct();
            }
            return default(TmphSubArray<int>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        public unsafe static TmphKeyValue<int, int>[] sortGroupCount(this TmphSubArray<int> array)
        {
            if (array.Count != 0)
            {
                TmphArrayExtension.sort(array.Array, array.StartIndex, array.Count);
                fixed (int* valueFixed = array.Array)
                {
                    int* start = valueFixed + array.StartIndex, lastStart = start, end = start + array.Count;
                    int value = *start;
                    int count = 1;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            ++count;
                            value = *start;
                        }
                    }
                    TmphKeyValue<int, int>[] values = new TmphKeyValue<int, int>[count];
                    value = *(start = lastStart);
                    count = 0;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            values[count++].Set(value, (int)(start - lastStart));
                            value = *start;
                            lastStart = start;
                        }
                    }
                    values[count].Set(value, (int)(start - lastStart));
                    return values;
                }
            }
            return TmphNullValue<TmphKeyValue<int, int>>.Array;
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static TmphSubArray<TmphSubArray<TValueType>> sortGroup<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, int> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] sortArray = TmphArrayExtension.getSort(array.Array, getValue, array.StartIndex, array.Count);
                TmphSubArray<TValueType>[] values = new TmphSubArray<TValueType>[sortArray.Length];
                int key = getValue(sortArray[0]);
                int startIndex = 0, valueIndex = 0;
                for (int index = 1; index != sortArray.Length; ++index)
                {
                    int nextKey = getValue(sortArray[index]);
                    if (key != nextKey)
                    {
                        values[valueIndex++].UnsafeSet(sortArray, startIndex, index - startIndex);
                        key = nextKey;
                        startIndex = index;
                    }
                }
                values[valueIndex++].UnsafeSet(sortArray, startIndex, sortArray.Length - startIndex);
                return TmphSubArray<TmphSubArray<TValueType>>.Unsafe(values, 0, valueIndex);
            }
            return default(TmphSubArray<TmphSubArray<TValueType>>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合数量</returns>
        public unsafe static int sortGroupCount<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, int> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] sortArray = TmphArrayExtension.getSort(array.Array, getValue, array.StartIndex, array.Count);
                int key = getValue(sortArray[0]);
                int count = 0;
                for (int index = 1; index != sortArray.Length; ++index)
                {
                    int nextKey = getValue(sortArray[index]);
                    if (key != nextKey)
                    {
                        ++count;
                        key = nextKey;
                    }
                }
                return count + 1;
            }
            return 0;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        public unsafe static TmphSubArray<DateTime> distinct(this DateTime[] array)
        {
            if (array == null) return default(TmphSubArray<DateTime>);
            if (array.Length <= 1) return TmphSubArray<DateTime>.Unsafe(array, 0, array.Length);
            TmphArrayExtension.sort(array, 0, array.Length);
            fixed (DateTime* valueFixed = array)
            {
                DateTime* start = valueFixed + 1, end = valueFixed + array.Length, write = valueFixed;
                do
                {
                    if (*start != *write) *++write = *start;
                }
                while (++start != end);
                return TmphSubArray<DateTime>.Unsafe(array, 0, (int)(write - valueFixed) + 1);
            }
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static TValueType[] distinct<TValueType>
            (this DateTime[] array, Func<DateTime, TValueType> getValue)
        {
            return new TmphSubArray<DateTime>(array).distinct(getValue);
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static TmphSubArray<DateTime> distinct<TValueType>
            (this TValueType[] array, Func<TValueType, DateTime> getValue)
        {
            if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
            DateTime[] newValues = array.getArray(getValue);
            TmphArrayExtension.sort(newValues, 0, newValues.Length);
            return newValues.distinct();
        }
        /// <summary>
        /// 求交集
        /// </summary>
        /// <param name="left">左侧数据</param>
        /// <param name="right">右侧数据</param>
        /// <returns>数据交集</returns>
        public unsafe static TmphSubArray<DateTime> intersect(this DateTime[] left, DateTime[] right)
        {
            int leftLength = left.length(), rightLength = right.length();
            if (leftLength != 0 && rightLength != 0)
            {
                DateTime[] min = leftLength <= rightLength ? left : right, values = new DateTime[min.Length];
                fixed (DateTime* valueFixed = values)
                {
                    DateTime* write = valueFixed;
                    TmphStaticHashSet<DateTime> hash = new TmphStaticHashSet<DateTime>(min);
                    foreach (DateTime value in leftLength <= rightLength ? right : left)
                    {
                        if (hash.Contains(value)) *write++ = value;
                    }
                    return TmphSubArray<DateTime>.Unsafe(values, 0, (int)(write - valueFixed));
                }
            }
            return default(TmphSubArray<DateTime>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        public static TmphKeyValue<DateTime, int>[] sortGroupCount(this DateTime[] array)
        {
            return new TmphSubArray<DateTime>(array).sortGroupCount();
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static TmphSubArray<TmphSubArray<TValueType>> sortGroup<TValueType>
            (this TValueType[] array, Func<TValueType, DateTime> getValue)
        {
            return new TmphSubArray<TValueType>(array).sortGroup(getValue);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>数据排序分组数量</returns>
        public static int sortGroupCount<TValueType>
            (this TValueType[] array, Func<TValueType, DateTime> getValue)
        {
            return new TmphSubArray<TValueType>(array).sortGroupCount(getValue);
        }
    }
    
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        public unsafe static TmphSubArray<DateTime> distinct(this TmphSubArray<DateTime> array)
        {
            if (array.Count > 1)
            {
                TmphArrayExtension.sort(array.Array, array.StartIndex, array.Count);
                fixed (DateTime* valueFixed = array.Array)
                {
                    DateTime* write = valueFixed + array.StartIndex, start = write + 1, end = write + array.Count;
                    do
                    {
                        if (*start != *write) *++write = *start;
                    }
                    while (++start != end);
                    return TmphSubArray<DateTime>.Unsafe(array.Array, array.StartIndex, (int)(write - valueFixed) + 1 - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static TValueType[] distinct<TValueType>
            (this TmphSubArray<DateTime> array, Func<DateTime, TValueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TmphArrayExtension.sort(array.Array, array.StartIndex, array.Count);
                fixed (DateTime* valueFixed = array.Array)
                {
                    DateTime* start = valueFixed + array.StartIndex, end = start + array.Count;
                    DateTime value = *start;
                    int count = 1;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            ++count;
                            value = *start;
                        }
                    }
                    TValueType[] values = new TValueType[count];
                    values[0] = getValue(value = *(start = valueFixed + array.StartIndex));
                    count = 1;
                    while (++start != end)
                    {
                        if (*start != value) values[count++] = getValue(value = *start);
                    }
                    return values;
                }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static TmphSubArray<DateTime> distinct<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, DateTime> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                DateTime[] newValues = array.getArray(getValue);
                TmphArrayExtension.sort(newValues, 0, newValues.Length);
                return newValues.distinct();
            }
            return default(TmphSubArray<DateTime>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        public unsafe static TmphKeyValue<DateTime, int>[] sortGroupCount(this TmphSubArray<DateTime> array)
        {
            if (array.Count != 0)
            {
                TmphArrayExtension.sort(array.Array, array.StartIndex, array.Count);
                fixed (DateTime* valueFixed = array.Array)
                {
                    DateTime* start = valueFixed + array.StartIndex, lastStart = start, end = start + array.Count;
                    DateTime value = *start;
                    int count = 1;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            ++count;
                            value = *start;
                        }
                    }
                    TmphKeyValue<DateTime, int>[] values = new TmphKeyValue<DateTime, int>[count];
                    value = *(start = lastStart);
                    count = 0;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            values[count++].Set(value, (int)(start - lastStart));
                            value = *start;
                            lastStart = start;
                        }
                    }
                    values[count].Set(value, (int)(start - lastStart));
                    return values;
                }
            }
            return TmphNullValue<TmphKeyValue<DateTime, int>>.Array;
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static TmphSubArray<TmphSubArray<TValueType>> sortGroup<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, DateTime> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] sortArray = TmphArrayExtension.getSort(array.Array, getValue, array.StartIndex, array.Count);
                TmphSubArray<TValueType>[] values = new TmphSubArray<TValueType>[sortArray.Length];
                DateTime key = getValue(sortArray[0]);
                int startIndex = 0, valueIndex = 0;
                for (int index = 1; index != sortArray.Length; ++index)
                {
                    DateTime nextKey = getValue(sortArray[index]);
                    if (key != nextKey)
                    {
                        values[valueIndex++].UnsafeSet(sortArray, startIndex, index - startIndex);
                        key = nextKey;
                        startIndex = index;
                    }
                }
                values[valueIndex++].UnsafeSet(sortArray, startIndex, sortArray.Length - startIndex);
                return TmphSubArray<TmphSubArray<TValueType>>.Unsafe(values, 0, valueIndex);
            }
            return default(TmphSubArray<TmphSubArray<TValueType>>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合数量</returns>
        public unsafe static int sortGroupCount<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, DateTime> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TValueType[] sortArray = TmphArrayExtension.getSort(array.Array, getValue, array.StartIndex, array.Count);
                DateTime key = getValue(sortArray[0]);
                int count = 0;
                for (int index = 1; index != sortArray.Length; ++index)
                {
                    DateTime nextKey = getValue(sortArray[index]);
                    if (key != nextKey)
                    {
                        ++count;
                        key = nextKey;
                    }
                }
                return count + 1;
            }
            return 0;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class TmphICollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static long[] getArray
            (this System.Collections.Generic.ICollection<long> values)
        {
            if (values.count() != 0)
            {
                long[] newValues = new long[values.Count];
                fixed (long* newValueFixed = newValues)
                {
                    long* write = newValueFixed;
                    foreach (long value in values) *write++ = value;
                }
                return newValues;
            }
            return TmphNullValue<long>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static long[] getArray<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, long> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                long[] newValues = new long[values.Count];
                fixed (long* newValueFixed = newValues)
                {
                    long* write = newValueFixed;
                    foreach (TValueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return TmphNullValue<long>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        public static TmphList<long> getList<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, long> getValue)
        {
            return values != null ? new TmphList<long>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        public static TmphList<long> getList(this System.Collections.Generic.ICollection<long> values)
        {
            return values != null ? new TmphList<long>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        public static TmphCollection<long> getCollection<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, long> getValue)
        {
            return values != null ? new TmphCollection<long>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        public static TmphCollection<long> getCollection
            (this System.Collections.Generic.ICollection<long> values)
        {
            return values != null ? new TmphCollection<long>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static TmphSubArray<long> getFind
            (this System.Collections.Generic.ICollection<long> values, Func<long, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                long[] newValues = new long[values.Count];
                fixed (long* newValueFixed = newValues)
                {
                    long* write = newValueFixed;
                    foreach (long value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return TmphSubArray<long>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(TmphSubArray<long>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static TmphSubArray<long> getFind
            (this System.Collections.ICollection values, Func<long, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                long[] newValues = new long[values.Count];
                fixed (long* newValueFixed = newValues)
                {
                    long* write = newValueFixed;
                    foreach (long value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return TmphSubArray<long>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(TmphSubArray<long>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static long[] getFindArray
            (this System.Collections.Generic.ICollection<long> values, Func<long, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static long[] getFindArray
            (this System.Collections.ICollection values, Func<long, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class TmphICollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static uint[] getArray
            (this System.Collections.Generic.ICollection<uint> values)
        {
            if (values.count() != 0)
            {
                uint[] newValues = new uint[values.Count];
                fixed (uint* newValueFixed = newValues)
                {
                    uint* write = newValueFixed;
                    foreach (uint value in values) *write++ = value;
                }
                return newValues;
            }
            return TmphNullValue<uint>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static uint[] getArray<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, uint> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                uint[] newValues = new uint[values.Count];
                fixed (uint* newValueFixed = newValues)
                {
                    uint* write = newValueFixed;
                    foreach (TValueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return TmphNullValue<uint>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        public static TmphList<uint> getList<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, uint> getValue)
        {
            return values != null ? new TmphList<uint>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        public static TmphList<uint> getList(this System.Collections.Generic.ICollection<uint> values)
        {
            return values != null ? new TmphList<uint>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        public static TmphCollection<uint> getCollection<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, uint> getValue)
        {
            return values != null ? new TmphCollection<uint>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        public static TmphCollection<uint> getCollection
            (this System.Collections.Generic.ICollection<uint> values)
        {
            return values != null ? new TmphCollection<uint>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static TmphSubArray<uint> getFind
            (this System.Collections.Generic.ICollection<uint> values, Func<uint, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                uint[] newValues = new uint[values.Count];
                fixed (uint* newValueFixed = newValues)
                {
                    uint* write = newValueFixed;
                    foreach (uint value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return TmphSubArray<uint>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(TmphSubArray<uint>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static TmphSubArray<uint> getFind
            (this System.Collections.ICollection values, Func<uint, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                uint[] newValues = new uint[values.Count];
                fixed (uint* newValueFixed = newValues)
                {
                    uint* write = newValueFixed;
                    foreach (uint value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return TmphSubArray<uint>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(TmphSubArray<uint>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static uint[] getFindArray
            (this System.Collections.Generic.ICollection<uint> values, Func<uint, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static uint[] getFindArray
            (this System.Collections.ICollection values, Func<uint, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class TmphICollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static int[] getArray
            (this System.Collections.Generic.ICollection<int> values)
        {
            if (values.count() != 0)
            {
                int[] newValues = new int[values.Count];
                fixed (int* newValueFixed = newValues)
                {
                    int* write = newValueFixed;
                    foreach (int value in values) *write++ = value;
                }
                return newValues;
            }
            return TmphNullValue<int>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static int[] getArray<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, int> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int[] newValues = new int[values.Count];
                fixed (int* newValueFixed = newValues)
                {
                    int* write = newValueFixed;
                    foreach (TValueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return TmphNullValue<int>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        public static TmphList<int> getList<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, int> getValue)
        {
            return values != null ? new TmphList<int>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        public static TmphList<int> getList(this System.Collections.Generic.ICollection<int> values)
        {
            return values != null ? new TmphList<int>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        public static TmphCollection<int> getCollection<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, int> getValue)
        {
            return values != null ? new TmphCollection<int>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        public static TmphCollection<int> getCollection
            (this System.Collections.Generic.ICollection<int> values)
        {
            return values != null ? new TmphCollection<int>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static TmphSubArray<int> getFind
            (this System.Collections.Generic.ICollection<int> values, Func<int, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int[] newValues = new int[values.Count];
                fixed (int* newValueFixed = newValues)
                {
                    int* write = newValueFixed;
                    foreach (int value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return TmphSubArray<int>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(TmphSubArray<int>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static TmphSubArray<int> getFind
            (this System.Collections.ICollection values, Func<int, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int[] newValues = new int[values.Count];
                fixed (int* newValueFixed = newValues)
                {
                    int* write = newValueFixed;
                    foreach (int value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return TmphSubArray<int>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(TmphSubArray<int>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static int[] getFindArray
            (this System.Collections.Generic.ICollection<int> values, Func<int, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static int[] getFindArray
            (this System.Collections.ICollection values, Func<int, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class TmphICollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static ushort[] getArray
            (this System.Collections.Generic.ICollection<ushort> values)
        {
            if (values.count() != 0)
            {
                ushort[] newValues = new ushort[values.Count];
                fixed (ushort* newValueFixed = newValues)
                {
                    ushort* write = newValueFixed;
                    foreach (ushort value in values) *write++ = value;
                }
                return newValues;
            }
            return TmphNullValue<ushort>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static ushort[] getArray<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, ushort> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                ushort[] newValues = new ushort[values.Count];
                fixed (ushort* newValueFixed = newValues)
                {
                    ushort* write = newValueFixed;
                    foreach (TValueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return TmphNullValue<ushort>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        public static TmphList<ushort> getList<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, ushort> getValue)
        {
            return values != null ? new TmphList<ushort>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        public static TmphList<ushort> getList(this System.Collections.Generic.ICollection<ushort> values)
        {
            return values != null ? new TmphList<ushort>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        public static TmphCollection<ushort> getCollection<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, ushort> getValue)
        {
            return values != null ? new TmphCollection<ushort>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        public static TmphCollection<ushort> getCollection
            (this System.Collections.Generic.ICollection<ushort> values)
        {
            return values != null ? new TmphCollection<ushort>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static TmphSubArray<ushort> getFind
            (this System.Collections.Generic.ICollection<ushort> values, Func<ushort, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                ushort[] newValues = new ushort[values.Count];
                fixed (ushort* newValueFixed = newValues)
                {
                    ushort* write = newValueFixed;
                    foreach (ushort value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return TmphSubArray<ushort>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(TmphSubArray<ushort>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static TmphSubArray<ushort> getFind
            (this System.Collections.ICollection values, Func<ushort, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                ushort[] newValues = new ushort[values.Count];
                fixed (ushort* newValueFixed = newValues)
                {
                    ushort* write = newValueFixed;
                    foreach (ushort value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return TmphSubArray<ushort>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(TmphSubArray<ushort>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static ushort[] getFindArray
            (this System.Collections.Generic.ICollection<ushort> values, Func<ushort, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static ushort[] getFindArray
            (this System.Collections.ICollection values, Func<ushort, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class TmphICollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static short[] getArray
            (this System.Collections.Generic.ICollection<short> values)
        {
            if (values.count() != 0)
            {
                short[] newValues = new short[values.Count];
                fixed (short* newValueFixed = newValues)
                {
                    short* write = newValueFixed;
                    foreach (short value in values) *write++ = value;
                }
                return newValues;
            }
            return TmphNullValue<short>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static short[] getArray<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, short> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                short[] newValues = new short[values.Count];
                fixed (short* newValueFixed = newValues)
                {
                    short* write = newValueFixed;
                    foreach (TValueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return TmphNullValue<short>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        public static TmphList<short> getList<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, short> getValue)
        {
            return values != null ? new TmphList<short>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        public static TmphList<short> getList(this System.Collections.Generic.ICollection<short> values)
        {
            return values != null ? new TmphList<short>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        public static TmphCollection<short> getCollection<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, short> getValue)
        {
            return values != null ? new TmphCollection<short>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        public static TmphCollection<short> getCollection
            (this System.Collections.Generic.ICollection<short> values)
        {
            return values != null ? new TmphCollection<short>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static TmphSubArray<short> getFind
            (this System.Collections.Generic.ICollection<short> values, Func<short, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                short[] newValues = new short[values.Count];
                fixed (short* newValueFixed = newValues)
                {
                    short* write = newValueFixed;
                    foreach (short value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return TmphSubArray<short>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(TmphSubArray<short>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static TmphSubArray<short> getFind
            (this System.Collections.ICollection values, Func<short, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                short[] newValues = new short[values.Count];
                fixed (short* newValueFixed = newValues)
                {
                    short* write = newValueFixed;
                    foreach (short value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return TmphSubArray<short>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(TmphSubArray<short>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static short[] getFindArray
            (this System.Collections.Generic.ICollection<short> values, Func<short, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static short[] getFindArray
            (this System.Collections.ICollection values, Func<short, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class TmphICollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static byte[] getArray
            (this System.Collections.Generic.ICollection<byte> values)
        {
            if (values.count() != 0)
            {
                byte[] newValues = new byte[values.Count];
                fixed (byte* newValueFixed = newValues)
                {
                    byte* write = newValueFixed;
                    foreach (byte value in values) *write++ = value;
                }
                return newValues;
            }
            return TmphNullValue<byte>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static byte[] getArray<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, byte> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                byte[] newValues = new byte[values.Count];
                fixed (byte* newValueFixed = newValues)
                {
                    byte* write = newValueFixed;
                    foreach (TValueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return TmphNullValue<byte>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        public static TmphList<byte> getList<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, byte> getValue)
        {
            return values != null ? new TmphList<byte>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        public static TmphList<byte> getList(this System.Collections.Generic.ICollection<byte> values)
        {
            return values != null ? new TmphList<byte>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        public static TmphCollection<byte> getCollection<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, byte> getValue)
        {
            return values != null ? new TmphCollection<byte>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        public static TmphCollection<byte> getCollection
            (this System.Collections.Generic.ICollection<byte> values)
        {
            return values != null ? new TmphCollection<byte>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static TmphSubArray<byte> getFind
            (this System.Collections.Generic.ICollection<byte> values, Func<byte, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                byte[] newValues = new byte[values.Count];
                fixed (byte* newValueFixed = newValues)
                {
                    byte* write = newValueFixed;
                    foreach (byte value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return TmphSubArray<byte>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(TmphSubArray<byte>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static TmphSubArray<byte> getFind
            (this System.Collections.ICollection values, Func<byte, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                byte[] newValues = new byte[values.Count];
                fixed (byte* newValueFixed = newValues)
                {
                    byte* write = newValueFixed;
                    foreach (byte value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return TmphSubArray<byte>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(TmphSubArray<byte>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static byte[] getFindArray
            (this System.Collections.Generic.ICollection<byte> values, Func<byte, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static byte[] getFindArray
            (this System.Collections.ICollection values, Func<byte, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class TmphICollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static sbyte[] getArray
            (this System.Collections.Generic.ICollection<sbyte> values)
        {
            if (values.count() != 0)
            {
                sbyte[] newValues = new sbyte[values.Count];
                fixed (sbyte* newValueFixed = newValues)
                {
                    sbyte* write = newValueFixed;
                    foreach (sbyte value in values) *write++ = value;
                }
                return newValues;
            }
            return TmphNullValue<sbyte>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static sbyte[] getArray<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, sbyte> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                sbyte[] newValues = new sbyte[values.Count];
                fixed (sbyte* newValueFixed = newValues)
                {
                    sbyte* write = newValueFixed;
                    foreach (TValueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return TmphNullValue<sbyte>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        public static TmphList<sbyte> getList<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, sbyte> getValue)
        {
            return values != null ? new TmphList<sbyte>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        public static TmphList<sbyte> getList(this System.Collections.Generic.ICollection<sbyte> values)
        {
            return values != null ? new TmphList<sbyte>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        public static TmphCollection<sbyte> getCollection<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, sbyte> getValue)
        {
            return values != null ? new TmphCollection<sbyte>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        public static TmphCollection<sbyte> getCollection
            (this System.Collections.Generic.ICollection<sbyte> values)
        {
            return values != null ? new TmphCollection<sbyte>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static TmphSubArray<sbyte> getFind
            (this System.Collections.Generic.ICollection<sbyte> values, Func<sbyte, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                sbyte[] newValues = new sbyte[values.Count];
                fixed (sbyte* newValueFixed = newValues)
                {
                    sbyte* write = newValueFixed;
                    foreach (sbyte value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return TmphSubArray<sbyte>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(TmphSubArray<sbyte>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static TmphSubArray<sbyte> getFind
            (this System.Collections.ICollection values, Func<sbyte, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                sbyte[] newValues = new sbyte[values.Count];
                fixed (sbyte* newValueFixed = newValues)
                {
                    sbyte* write = newValueFixed;
                    foreach (sbyte value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return TmphSubArray<sbyte>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(TmphSubArray<sbyte>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static sbyte[] getFindArray
            (this System.Collections.Generic.ICollection<sbyte> values, Func<sbyte, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static sbyte[] getFindArray
            (this System.Collections.ICollection values, Func<sbyte, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class TmphICollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static double[] getArray
            (this System.Collections.Generic.ICollection<double> values)
        {
            if (values.count() != 0)
            {
                double[] newValues = new double[values.Count];
                fixed (double* newValueFixed = newValues)
                {
                    double* write = newValueFixed;
                    foreach (double value in values) *write++ = value;
                }
                return newValues;
            }
            return TmphNullValue<double>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static double[] getArray<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, double> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                double[] newValues = new double[values.Count];
                fixed (double* newValueFixed = newValues)
                {
                    double* write = newValueFixed;
                    foreach (TValueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return TmphNullValue<double>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        public static TmphList<double> getList<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, double> getValue)
        {
            return values != null ? new TmphList<double>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        public static TmphList<double> getList(this System.Collections.Generic.ICollection<double> values)
        {
            return values != null ? new TmphList<double>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        public static TmphCollection<double> getCollection<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, double> getValue)
        {
            return values != null ? new TmphCollection<double>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        public static TmphCollection<double> getCollection
            (this System.Collections.Generic.ICollection<double> values)
        {
            return values != null ? new TmphCollection<double>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static TmphSubArray<double> getFind
            (this System.Collections.Generic.ICollection<double> values, Func<double, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                double[] newValues = new double[values.Count];
                fixed (double* newValueFixed = newValues)
                {
                    double* write = newValueFixed;
                    foreach (double value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return TmphSubArray<double>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(TmphSubArray<double>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static TmphSubArray<double> getFind
            (this System.Collections.ICollection values, Func<double, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                double[] newValues = new double[values.Count];
                fixed (double* newValueFixed = newValues)
                {
                    double* write = newValueFixed;
                    foreach (double value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return TmphSubArray<double>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(TmphSubArray<double>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static double[] getFindArray
            (this System.Collections.Generic.ICollection<double> values, Func<double, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static double[] getFindArray
            (this System.Collections.ICollection values, Func<double, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class TmphICollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static float[] getArray
            (this System.Collections.Generic.ICollection<float> values)
        {
            if (values.count() != 0)
            {
                float[] newValues = new float[values.Count];
                fixed (float* newValueFixed = newValues)
                {
                    float* write = newValueFixed;
                    foreach (float value in values) *write++ = value;
                }
                return newValues;
            }
            return TmphNullValue<float>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static float[] getArray<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, float> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                float[] newValues = new float[values.Count];
                fixed (float* newValueFixed = newValues)
                {
                    float* write = newValueFixed;
                    foreach (TValueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return TmphNullValue<float>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        public static TmphList<float> getList<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, float> getValue)
        {
            return values != null ? new TmphList<float>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        public static TmphList<float> getList(this System.Collections.Generic.ICollection<float> values)
        {
            return values != null ? new TmphList<float>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        public static TmphCollection<float> getCollection<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, float> getValue)
        {
            return values != null ? new TmphCollection<float>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        public static TmphCollection<float> getCollection
            (this System.Collections.Generic.ICollection<float> values)
        {
            return values != null ? new TmphCollection<float>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static TmphSubArray<float> getFind
            (this System.Collections.Generic.ICollection<float> values, Func<float, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                float[] newValues = new float[values.Count];
                fixed (float* newValueFixed = newValues)
                {
                    float* write = newValueFixed;
                    foreach (float value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return TmphSubArray<float>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(TmphSubArray<float>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static TmphSubArray<float> getFind
            (this System.Collections.ICollection values, Func<float, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                float[] newValues = new float[values.Count];
                fixed (float* newValueFixed = newValues)
                {
                    float* write = newValueFixed;
                    foreach (float value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return TmphSubArray<float>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(TmphSubArray<float>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static float[] getFindArray
            (this System.Collections.Generic.ICollection<float> values, Func<float, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static float[] getFindArray
            (this System.Collections.ICollection values, Func<float, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class TmphICollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static DateTime[] getArray
            (this System.Collections.Generic.ICollection<DateTime> values)
        {
            if (values.count() != 0)
            {
                DateTime[] newValues = new DateTime[values.Count];
                fixed (DateTime* newValueFixed = newValues)
                {
                    DateTime* write = newValueFixed;
                    foreach (DateTime value in values) *write++ = value;
                }
                return newValues;
            }
            return TmphNullValue<DateTime>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static DateTime[] getArray<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, DateTime> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                DateTime[] newValues = new DateTime[values.Count];
                fixed (DateTime* newValueFixed = newValues)
                {
                    DateTime* write = newValueFixed;
                    foreach (TValueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return TmphNullValue<DateTime>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        public static TmphList<DateTime> getList<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, DateTime> getValue)
        {
            return values != null ? new TmphList<DateTime>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        public static TmphList<DateTime> getList(this System.Collections.Generic.ICollection<DateTime> values)
        {
            return values != null ? new TmphList<DateTime>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="TValueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        public static TmphCollection<DateTime> getCollection<TValueType>
            (this System.Collections.Generic.ICollection<TValueType> values, Func<TValueType, DateTime> getValue)
        {
            return values != null ? new TmphCollection<DateTime>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        public static TmphCollection<DateTime> getCollection
            (this System.Collections.Generic.ICollection<DateTime> values)
        {
            return values != null ? new TmphCollection<DateTime>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static TmphSubArray<DateTime> getFind
            (this System.Collections.Generic.ICollection<DateTime> values, Func<DateTime, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                DateTime[] newValues = new DateTime[values.Count];
                fixed (DateTime* newValueFixed = newValues)
                {
                    DateTime* write = newValueFixed;
                    foreach (DateTime value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return TmphSubArray<DateTime>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(TmphSubArray<DateTime>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static TmphSubArray<DateTime> getFind
            (this System.Collections.ICollection values, Func<DateTime, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                DateTime[] newValues = new DateTime[values.Count];
                fixed (DateTime* newValueFixed = newValues)
                {
                    DateTime* write = newValueFixed;
                    foreach (DateTime value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return TmphSubArray<DateTime>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(TmphSubArray<DateTime>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static DateTime[] getFindArray
            (this System.Collections.Generic.ICollection<DateTime> values, Func<DateTime, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static DateTime[] getFindArray
            (this System.Collections.ICollection values, Func<DateTime, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class TmphIEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<long> values, out long value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = long.MinValue;
                foreach (long nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static long max
            (this System.Collections.Generic.IEnumerable<long> values, long TmphNullValue)
        {
            long value;
            return max(values, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, long> getKey
            , out TValueType value)
        {
            value = default(TValueType);
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                long key = long.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        long nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, long> getKey
            , TValueType TmphNullValue)
        {
            TValueType value;
            return max(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, long> getKey
            , out long value)
        {
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                value = long.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        long nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static long maxKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, long> getKey
            , long TmphNullValue)
        {
            long value;
            return maxKey(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<long> values, out long value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = long.MinValue;
                foreach (long nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static long min
            (this System.Collections.Generic.IEnumerable<long> values, long TmphNullValue)
        {
            long value;
            return min(values, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, long> getKey
            , out TValueType value)
        {
            value = default(TValueType);
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                long key = long.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        long nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, long> getKey
            , TValueType TmphNullValue)
        {
            TValueType value;
            return min(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, long> getKey
            , out long value)
        {
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                value = long.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        long nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static long minKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, long> getKey
            , long TmphNullValue)
        {
            long value;
            return minKey(values, getKey, out value) ? value : TmphNullValue;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class TmphIEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<uint> values, out uint value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = uint.MinValue;
                foreach (uint nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static uint max
            (this System.Collections.Generic.IEnumerable<uint> values, uint TmphNullValue)
        {
            uint value;
            return max(values, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, uint> getKey
            , out TValueType value)
        {
            value = default(TValueType);
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                uint key = uint.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        uint nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, uint> getKey
            , TValueType TmphNullValue)
        {
            TValueType value;
            return max(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, uint> getKey
            , out uint value)
        {
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                value = uint.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        uint nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static uint maxKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, uint> getKey
            , uint TmphNullValue)
        {
            uint value;
            return maxKey(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<uint> values, out uint value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = uint.MinValue;
                foreach (uint nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static uint min
            (this System.Collections.Generic.IEnumerable<uint> values, uint TmphNullValue)
        {
            uint value;
            return min(values, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, uint> getKey
            , out TValueType value)
        {
            value = default(TValueType);
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                uint key = uint.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        uint nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, uint> getKey
            , TValueType TmphNullValue)
        {
            TValueType value;
            return min(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, uint> getKey
            , out uint value)
        {
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                value = uint.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        uint nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static uint minKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, uint> getKey
            , uint TmphNullValue)
        {
            uint value;
            return minKey(values, getKey, out value) ? value : TmphNullValue;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class TmphIEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<int> values, out int value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = int.MinValue;
                foreach (int nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static int max
            (this System.Collections.Generic.IEnumerable<int> values, int TmphNullValue)
        {
            int value;
            return max(values, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, int> getKey
            , out TValueType value)
        {
            value = default(TValueType);
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                int key = int.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        int nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, int> getKey
            , TValueType TmphNullValue)
        {
            TValueType value;
            return max(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, int> getKey
            , out int value)
        {
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                value = int.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        int nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static int maxKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, int> getKey
            , int TmphNullValue)
        {
            int value;
            return maxKey(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<int> values, out int value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = int.MinValue;
                foreach (int nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static int min
            (this System.Collections.Generic.IEnumerable<int> values, int TmphNullValue)
        {
            int value;
            return min(values, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, int> getKey
            , out TValueType value)
        {
            value = default(TValueType);
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                int key = int.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        int nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, int> getKey
            , TValueType TmphNullValue)
        {
            TValueType value;
            return min(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, int> getKey
            , out int value)
        {
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                value = int.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        int nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static int minKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, int> getKey
            , int TmphNullValue)
        {
            int value;
            return minKey(values, getKey, out value) ? value : TmphNullValue;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class TmphIEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<ushort> values, out ushort value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = ushort.MinValue;
                foreach (ushort nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static ushort max
            (this System.Collections.Generic.IEnumerable<ushort> values, ushort TmphNullValue)
        {
            ushort value;
            return max(values, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, ushort> getKey
            , out TValueType value)
        {
            value = default(TValueType);
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                ushort key = ushort.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        ushort nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, ushort> getKey
            , TValueType TmphNullValue)
        {
            TValueType value;
            return max(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, ushort> getKey
            , out ushort value)
        {
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                value = ushort.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        ushort nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static ushort maxKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, ushort> getKey
            , ushort TmphNullValue)
        {
            ushort value;
            return maxKey(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<ushort> values, out ushort value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = ushort.MinValue;
                foreach (ushort nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static ushort min
            (this System.Collections.Generic.IEnumerable<ushort> values, ushort TmphNullValue)
        {
            ushort value;
            return min(values, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, ushort> getKey
            , out TValueType value)
        {
            value = default(TValueType);
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                ushort key = ushort.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        ushort nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, ushort> getKey
            , TValueType TmphNullValue)
        {
            TValueType value;
            return min(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, ushort> getKey
            , out ushort value)
        {
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                value = ushort.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        ushort nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static ushort minKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, ushort> getKey
            , ushort TmphNullValue)
        {
            ushort value;
            return minKey(values, getKey, out value) ? value : TmphNullValue;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class TmphIEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<short> values, out short value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = short.MinValue;
                foreach (short nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static short max
            (this System.Collections.Generic.IEnumerable<short> values, short TmphNullValue)
        {
            short value;
            return max(values, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, short> getKey
            , out TValueType value)
        {
            value = default(TValueType);
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                short key = short.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        short nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, short> getKey
            , TValueType TmphNullValue)
        {
            TValueType value;
            return max(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, short> getKey
            , out short value)
        {
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                value = short.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        short nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static short maxKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, short> getKey
            , short TmphNullValue)
        {
            short value;
            return maxKey(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<short> values, out short value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = short.MinValue;
                foreach (short nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static short min
            (this System.Collections.Generic.IEnumerable<short> values, short TmphNullValue)
        {
            short value;
            return min(values, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, short> getKey
            , out TValueType value)
        {
            value = default(TValueType);
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                short key = short.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        short nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, short> getKey
            , TValueType TmphNullValue)
        {
            TValueType value;
            return min(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, short> getKey
            , out short value)
        {
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                value = short.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        short nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static short minKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, short> getKey
            , short TmphNullValue)
        {
            short value;
            return minKey(values, getKey, out value) ? value : TmphNullValue;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class TmphIEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<byte> values, out byte value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = byte.MinValue;
                foreach (byte nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static byte max
            (this System.Collections.Generic.IEnumerable<byte> values, byte TmphNullValue)
        {
            byte value;
            return max(values, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, byte> getKey
            , out TValueType value)
        {
            value = default(TValueType);
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                byte key = byte.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        byte nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, byte> getKey
            , TValueType TmphNullValue)
        {
            TValueType value;
            return max(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, byte> getKey
            , out byte value)
        {
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                value = byte.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        byte nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static byte maxKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, byte> getKey
            , byte TmphNullValue)
        {
            byte value;
            return maxKey(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<byte> values, out byte value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = byte.MinValue;
                foreach (byte nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static byte min
            (this System.Collections.Generic.IEnumerable<byte> values, byte TmphNullValue)
        {
            byte value;
            return min(values, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, byte> getKey
            , out TValueType value)
        {
            value = default(TValueType);
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                byte key = byte.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        byte nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, byte> getKey
            , TValueType TmphNullValue)
        {
            TValueType value;
            return min(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, byte> getKey
            , out byte value)
        {
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                value = byte.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        byte nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static byte minKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, byte> getKey
            , byte TmphNullValue)
        {
            byte value;
            return minKey(values, getKey, out value) ? value : TmphNullValue;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class TmphIEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<sbyte> values, out sbyte value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = sbyte.MinValue;
                foreach (sbyte nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static sbyte max
            (this System.Collections.Generic.IEnumerable<sbyte> values, sbyte TmphNullValue)
        {
            sbyte value;
            return max(values, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, sbyte> getKey
            , out TValueType value)
        {
            value = default(TValueType);
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                sbyte key = sbyte.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        sbyte nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, sbyte> getKey
            , TValueType TmphNullValue)
        {
            TValueType value;
            return max(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, sbyte> getKey
            , out sbyte value)
        {
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                value = sbyte.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        sbyte nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static sbyte maxKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, sbyte> getKey
            , sbyte TmphNullValue)
        {
            sbyte value;
            return maxKey(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<sbyte> values, out sbyte value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = sbyte.MinValue;
                foreach (sbyte nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static sbyte min
            (this System.Collections.Generic.IEnumerable<sbyte> values, sbyte TmphNullValue)
        {
            sbyte value;
            return min(values, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, sbyte> getKey
            , out TValueType value)
        {
            value = default(TValueType);
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                sbyte key = sbyte.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        sbyte nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, sbyte> getKey
            , TValueType TmphNullValue)
        {
            TValueType value;
            return min(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, sbyte> getKey
            , out sbyte value)
        {
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                value = sbyte.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        sbyte nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static sbyte minKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, sbyte> getKey
            , sbyte TmphNullValue)
        {
            sbyte value;
            return minKey(values, getKey, out value) ? value : TmphNullValue;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class TmphIEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<double> values, out double value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = double.MinValue;
                foreach (double nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static double max
            (this System.Collections.Generic.IEnumerable<double> values, double TmphNullValue)
        {
            double value;
            return max(values, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, double> getKey
            , out TValueType value)
        {
            value = default(TValueType);
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                double key = double.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        double nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, double> getKey
            , TValueType TmphNullValue)
        {
            TValueType value;
            return max(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, double> getKey
            , out double value)
        {
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                value = double.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        double nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static double maxKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, double> getKey
            , double TmphNullValue)
        {
            double value;
            return maxKey(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<double> values, out double value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = double.MinValue;
                foreach (double nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static double min
            (this System.Collections.Generic.IEnumerable<double> values, double TmphNullValue)
        {
            double value;
            return min(values, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, double> getKey
            , out TValueType value)
        {
            value = default(TValueType);
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                double key = double.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        double nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, double> getKey
            , TValueType TmphNullValue)
        {
            TValueType value;
            return min(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, double> getKey
            , out double value)
        {
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                value = double.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        double nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static double minKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, double> getKey
            , double TmphNullValue)
        {
            double value;
            return minKey(values, getKey, out value) ? value : TmphNullValue;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class TmphIEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<float> values, out float value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = float.MinValue;
                foreach (float nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static float max
            (this System.Collections.Generic.IEnumerable<float> values, float TmphNullValue)
        {
            float value;
            return max(values, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, float> getKey
            , out TValueType value)
        {
            value = default(TValueType);
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                float key = float.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        float nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, float> getKey
            , TValueType TmphNullValue)
        {
            TValueType value;
            return max(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, float> getKey
            , out float value)
        {
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                value = float.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        float nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static float maxKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, float> getKey
            , float TmphNullValue)
        {
            float value;
            return maxKey(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<float> values, out float value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = float.MinValue;
                foreach (float nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static float min
            (this System.Collections.Generic.IEnumerable<float> values, float TmphNullValue)
        {
            float value;
            return min(values, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, float> getKey
            , out TValueType value)
        {
            value = default(TValueType);
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                float key = float.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        float nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, float> getKey
            , TValueType TmphNullValue)
        {
            TValueType value;
            return min(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, float> getKey
            , out float value)
        {
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                value = float.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        float nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static float minKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, float> getKey
            , float TmphNullValue)
        {
            float value;
            return minKey(values, getKey, out value) ? value : TmphNullValue;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class TmphIEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<DateTime> values, out DateTime value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = DateTime.MinValue;
                foreach (DateTime nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static DateTime max
            (this System.Collections.Generic.IEnumerable<DateTime> values, DateTime TmphNullValue)
        {
            DateTime value;
            return max(values, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, DateTime> getKey
            , out TValueType value)
        {
            value = default(TValueType);
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                DateTime key = DateTime.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        DateTime nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static TValueType max<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, DateTime> getKey
            , TValueType TmphNullValue)
        {
            TValueType value;
            return max(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, DateTime> getKey
            , out DateTime value)
        {
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                value = DateTime.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        DateTime nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        public static DateTime maxKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, DateTime> getKey
            , DateTime TmphNullValue)
        {
            DateTime value;
            return maxKey(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<DateTime> values, out DateTime value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = DateTime.MinValue;
                foreach (DateTime nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static DateTime min
            (this System.Collections.Generic.IEnumerable<DateTime> values, DateTime TmphNullValue)
        {
            DateTime value;
            return min(values, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, DateTime> getKey
            , out TValueType value)
        {
            value = default(TValueType);
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                DateTime key = DateTime.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        DateTime nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static TValueType min<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, DateTime> getKey
            , TValueType TmphNullValue)
        {
            TValueType value;
            return min(values, getKey, out value) ? value : TmphNullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, DateTime> getKey
            , out DateTime value)
        {
            if (values != null)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                int count = -1;
                value = DateTime.MinValue;
                foreach (TValueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        DateTime nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="TValueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        public static DateTime minKey<TValueType>
            (this System.Collections.Generic.IEnumerable<TValueType> values, Func<TValueType, DateTime> getKey
            , DateTime TmphNullValue)
        {
            DateTime value;
            return minKey(values, getKey, out value) ? value : TmphNullValue;
        }
    }
}

namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (ulong* startIndex, ulong* endIndex)
        {
            do
            {
                ulong leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                ulong* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                ulong value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void SortDesc(ulong[] values)
        {
            if (values.Length > 1)
            {
                fixed (ulong* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static ulong[] GetSortDesc(ulong[] values)
        {
            if (values.Length != 0)
            {
                ulong[] newValue = new ulong[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(ulong));
                fixed (ulong* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void SortDesc(ulong[] values, int startIndex, int count)
        {
            fixed (ulong* valueFixed = values)
            {
                ulong* start = valueFixed + startIndex;
                sortDesc(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static ulong[] GetSortDesc
            (ulong[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                ulong[] newValues = new ulong[count];
                Buffer.BlockCopy(values, startIndex * sizeof(ulong), newValues, 0, count * sizeof(ulong));
                fixed (ulong* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return TmphNullValue<ulong>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        public unsafe static void sortDesc
            (ulongSortIndex* startIndex, ulongSortIndex* endIndex)
        {
            do
            {
                ulongSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                ulongSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                ulongSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                ulong value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, ulong> getKey)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(ulongSortIndex));
            TmphPointer data = pool.Get(values.Length * sizeof(ulongSortIndex));
            try
            {
                return getSortDesc(values, getKey, (ulongSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, ulong> getKey, ulongSortIndex* fixedIndex)
        {
            ulongSortIndex.Create(fixedIndex, values, getKey);
            sortDesc(fixedIndex, fixedIndex + values.Length - 1);
            return ulongSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, ulong> getKey, int startIndex, int count)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(ulongSortIndex));
            TmphPointer data = pool.Get(count * sizeof(ulongSortIndex));
            try
            {
                return getSortDesc(values, getKey, startIndex, count, (ulongSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, ulong> getKey, int startIndex, int count
            , ulongSortIndex* fixedIndex)
        {
            ulongSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sortDesc(fixedIndex, fixedIndex + count - 1);
            return ulongSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (long* startIndex, long* endIndex)
        {
            do
            {
                long leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                long* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                long value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void Sort(long[] values)
        {
            if (values.Length > 1)
            {
                fixed (long* valueFixed = values)
                {
                    sort(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static long[] GetSort(long[] values)
        {
            if (values.Length != 0)
            {
                long[] newValue = new long[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(long));
                fixed (long* newValueFixed = newValue, valueFixed = values)
                {
                    sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void Sort(long[] values, int startIndex, int count)
        {
            fixed (long* valueFixed = values)
            {
                long* start = valueFixed + startIndex;
                sort(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static long[] GetSort
            (long[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                long[] newValues = new long[count];
                Buffer.BlockCopy(values, startIndex * sizeof(long), newValues, 0, count * sizeof(long));
                fixed (long* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sort(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return TmphNullValue<long>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        public unsafe static void sort
            (TmphLongSortIndex* startIndex, TmphLongSortIndex* endIndex)
        {
            do
            {
                TmphLongSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                TmphLongSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                TmphLongSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                long value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSort<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphLongSortIndex));
            TmphPointer data = pool.Get(values.Length * sizeof(TmphLongSortIndex));
            try
            {
                return getSort(values, getKey, (TmphLongSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSort<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey, TmphLongSortIndex* fixedIndex)
        {
            TmphLongSortIndex.Create(fixedIndex, values, getKey);
            sort(fixedIndex, fixedIndex + values.Length - 1);
            return TmphLongSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSort<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey, int startIndex, int count)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphLongSortIndex));
            TmphPointer data = pool.Get(count * sizeof(TmphLongSortIndex));
            try
            {
                return getSort(values, getKey, startIndex, count, (TmphLongSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSort<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey, int startIndex, int count
            , TmphLongSortIndex* fixedIndex)
        {
            TmphLongSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sort(fixedIndex, fixedIndex + count - 1);
            return TmphLongSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (long* startIndex, long* endIndex)
        {
            do
            {
                long leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                long* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                long value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void SortDesc(long[] values)
        {
            if (values.Length > 1)
            {
                fixed (long* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static long[] GetSortDesc(long[] values)
        {
            if (values.Length != 0)
            {
                long[] newValue = new long[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(long));
                fixed (long* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void SortDesc(long[] values, int startIndex, int count)
        {
            fixed (long* valueFixed = values)
            {
                long* start = valueFixed + startIndex;
                sortDesc(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static long[] GetSortDesc
            (long[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                long[] newValues = new long[count];
                Buffer.BlockCopy(values, startIndex * sizeof(long), newValues, 0, count * sizeof(long));
                fixed (long* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return TmphNullValue<long>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        public unsafe static void sortDesc
            (TmphLongSortIndex* startIndex, TmphLongSortIndex* endIndex)
        {
            do
            {
                TmphLongSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                TmphLongSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                TmphLongSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                long value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphLongSortIndex));
            TmphPointer data = pool.Get(values.Length * sizeof(TmphLongSortIndex));
            try
            {
                return getSortDesc(values, getKey, (TmphLongSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey, TmphLongSortIndex* fixedIndex)
        {
            TmphLongSortIndex.Create(fixedIndex, values, getKey);
            sortDesc(fixedIndex, fixedIndex + values.Length - 1);
            return TmphLongSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey, int startIndex, int count)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphLongSortIndex));
            TmphPointer data = pool.Get(count * sizeof(TmphLongSortIndex));
            try
            {
                return getSortDesc(values, getKey, startIndex, count, (TmphLongSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey, int startIndex, int count
            , TmphLongSortIndex* fixedIndex)
        {
            TmphLongSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sortDesc(fixedIndex, fixedIndex + count - 1);
            return TmphLongSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (uint* startIndex, uint* endIndex)
        {
            do
            {
                uint leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                uint* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                uint value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void Sort(uint[] values)
        {
            if (values.Length > 1)
            {
                fixed (uint* valueFixed = values)
                {
                    sort(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static uint[] GetSort(uint[] values)
        {
            if (values.Length != 0)
            {
                uint[] newValue = new uint[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(uint));
                fixed (uint* newValueFixed = newValue, valueFixed = values)
                {
                    sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void Sort(uint[] values, int startIndex, int count)
        {
            fixed (uint* valueFixed = values)
            {
                uint* start = valueFixed + startIndex;
                sort(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static uint[] GetSort
            (uint[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                uint[] newValues = new uint[count];
                Buffer.BlockCopy(values, startIndex * sizeof(uint), newValues, 0, count * sizeof(uint));
                fixed (uint* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sort(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return TmphNullValue<uint>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        public unsafe static void sort
            (TmphUintSortIndex* startIndex, TmphUintSortIndex* endIndex)
        {
            do
            {
                TmphUintSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                TmphUintSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                TmphUintSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                uint value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSort<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphUintSortIndex));
            TmphPointer data = pool.Get(values.Length * sizeof(TmphUintSortIndex));
            try
            {
                return getSort(values, getKey, (TmphUintSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSort<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey, TmphUintSortIndex* fixedIndex)
        {
            TmphUintSortIndex.Create(fixedIndex, values, getKey);
            sort(fixedIndex, fixedIndex + values.Length - 1);
            return TmphUintSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSort<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey, int startIndex, int count)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphUintSortIndex));
            TmphPointer data = pool.Get(count * sizeof(TmphUintSortIndex));
            try
            {
                return getSort(values, getKey, startIndex, count, (TmphUintSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSort<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey, int startIndex, int count
            , TmphUintSortIndex* fixedIndex)
        {
            TmphUintSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sort(fixedIndex, fixedIndex + count - 1);
            return TmphUintSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (uint* startIndex, uint* endIndex)
        {
            do
            {
                uint leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                uint* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                uint value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void SortDesc(uint[] values)
        {
            if (values.Length > 1)
            {
                fixed (uint* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static uint[] GetSortDesc(uint[] values)
        {
            if (values.Length != 0)
            {
                uint[] newValue = new uint[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(uint));
                fixed (uint* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void SortDesc(uint[] values, int startIndex, int count)
        {
            fixed (uint* valueFixed = values)
            {
                uint* start = valueFixed + startIndex;
                sortDesc(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static uint[] GetSortDesc
            (uint[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                uint[] newValues = new uint[count];
                Buffer.BlockCopy(values, startIndex * sizeof(uint), newValues, 0, count * sizeof(uint));
                fixed (uint* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return TmphNullValue<uint>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        public unsafe static void sortDesc
            (TmphUintSortIndex* startIndex, TmphUintSortIndex* endIndex)
        {
            do
            {
                TmphUintSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                TmphUintSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                TmphUintSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                uint value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphUintSortIndex));
            TmphPointer data = pool.Get(values.Length * sizeof(TmphUintSortIndex));
            try
            {
                return getSortDesc(values, getKey, (TmphUintSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey, TmphUintSortIndex* fixedIndex)
        {
            TmphUintSortIndex.Create(fixedIndex, values, getKey);
            sortDesc(fixedIndex, fixedIndex + values.Length - 1);
            return TmphUintSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey, int startIndex, int count)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphUintSortIndex));
            TmphPointer data = pool.Get(count * sizeof(TmphUintSortIndex));
            try
            {
                return getSortDesc(values, getKey, startIndex, count, (TmphUintSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey, int startIndex, int count
            , TmphUintSortIndex* fixedIndex)
        {
            TmphUintSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sortDesc(fixedIndex, fixedIndex + count - 1);
            return TmphUintSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (int* startIndex, int* endIndex)
        {
            do
            {
                int leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                int* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                int value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void Sort(int[] values)
        {
            if (values.Length > 1)
            {
                fixed (int* valueFixed = values)
                {
                    sort(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static int[] GetSort(int[] values)
        {
            if (values.Length != 0)
            {
                int[] newValue = new int[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(int));
                fixed (int* newValueFixed = newValue, valueFixed = values)
                {
                    sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void Sort(int[] values, int startIndex, int count)
        {
            fixed (int* valueFixed = values)
            {
                int* start = valueFixed + startIndex;
                sort(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static int[] GetSort
            (int[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                int[] newValues = new int[count];
                Buffer.BlockCopy(values, startIndex * sizeof(int), newValues, 0, count * sizeof(int));
                fixed (int* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sort(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return TmphNullValue<int>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        public unsafe static void sort
            (TmphIntSortIndex* startIndex, TmphIntSortIndex* endIndex)
        {
            do
            {
                TmphIntSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                TmphIntSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                TmphIntSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                int value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSort<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphIntSortIndex));
            TmphPointer data = pool.Get(values.Length * sizeof(TmphIntSortIndex));
            try
            {
                return getSort(values, getKey, (TmphIntSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSort<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey, TmphIntSortIndex* fixedIndex)
        {
            TmphIntSortIndex.Create(fixedIndex, values, getKey);
            sort(fixedIndex, fixedIndex + values.Length - 1);
            return TmphIntSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSort<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey, int startIndex, int count)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphIntSortIndex));
            TmphPointer data = pool.Get(count * sizeof(TmphIntSortIndex));
            try
            {
                return getSort(values, getKey, startIndex, count, (TmphIntSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSort<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey, int startIndex, int count
            , TmphIntSortIndex* fixedIndex)
        {
            TmphIntSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sort(fixedIndex, fixedIndex + count - 1);
            return TmphIntSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (int* startIndex, int* endIndex)
        {
            do
            {
                int leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                int* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                int value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void SortDesc(int[] values)
        {
            if (values.Length > 1)
            {
                fixed (int* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static int[] GetSortDesc(int[] values)
        {
            if (values.Length != 0)
            {
                int[] newValue = new int[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(int));
                fixed (int* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void SortDesc(int[] values, int startIndex, int count)
        {
            fixed (int* valueFixed = values)
            {
                int* start = valueFixed + startIndex;
                sortDesc(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static int[] GetSortDesc
            (int[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                int[] newValues = new int[count];
                Buffer.BlockCopy(values, startIndex * sizeof(int), newValues, 0, count * sizeof(int));
                fixed (int* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return TmphNullValue<int>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        public unsafe static void sortDesc
            (TmphIntSortIndex* startIndex, TmphIntSortIndex* endIndex)
        {
            do
            {
                TmphIntSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                TmphIntSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                TmphIntSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                int value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphIntSortIndex));
            TmphPointer data = pool.Get(values.Length * sizeof(TmphIntSortIndex));
            try
            {
                return getSortDesc(values, getKey, (TmphIntSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey, TmphIntSortIndex* fixedIndex)
        {
            TmphIntSortIndex.Create(fixedIndex, values, getKey);
            sortDesc(fixedIndex, fixedIndex + values.Length - 1);
            return TmphIntSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey, int startIndex, int count)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphIntSortIndex));
            TmphPointer data = pool.Get(count * sizeof(TmphIntSortIndex));
            try
            {
                return getSortDesc(values, getKey, startIndex, count, (TmphIntSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey, int startIndex, int count
            , TmphIntSortIndex* fixedIndex)
        {
            TmphIntSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sortDesc(fixedIndex, fixedIndex + count - 1);
            return TmphIntSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (double* startIndex, double* endIndex)
        {
            do
            {
                double leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                double* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                double value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void Sort(double[] values)
        {
            if (values.Length > 1)
            {
                fixed (double* valueFixed = values)
                {
                    sort(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static double[] GetSort(double[] values)
        {
            if (values.Length != 0)
            {
                double[] newValue = new double[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(double));
                fixed (double* newValueFixed = newValue, valueFixed = values)
                {
                    sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void Sort(double[] values, int startIndex, int count)
        {
            fixed (double* valueFixed = values)
            {
                double* start = valueFixed + startIndex;
                sort(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static double[] GetSort
            (double[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                double[] newValues = new double[count];
                Buffer.BlockCopy(values, startIndex * sizeof(double), newValues, 0, count * sizeof(double));
                fixed (double* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sort(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return TmphNullValue<double>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        public unsafe static void sort
            (TmphDoubleSortIndex* startIndex, TmphDoubleSortIndex* endIndex)
        {
            do
            {
                TmphDoubleSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                TmphDoubleSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                TmphDoubleSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                double value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSort<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphDoubleSortIndex));
            TmphPointer data = pool.Get(values.Length * sizeof(TmphDoubleSortIndex));
            try
            {
                return getSort(values, getKey, (TmphDoubleSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSort<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey, TmphDoubleSortIndex* fixedIndex)
        {
            TmphDoubleSortIndex.Create(fixedIndex, values, getKey);
            sort(fixedIndex, fixedIndex + values.Length - 1);
            return TmphDoubleSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSort<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey, int startIndex, int count)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphDoubleSortIndex));
            TmphPointer data = pool.Get(count * sizeof(TmphDoubleSortIndex));
            try
            {
                return getSort(values, getKey, startIndex, count, (TmphDoubleSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSort<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey, int startIndex, int count
            , TmphDoubleSortIndex* fixedIndex)
        {
            TmphDoubleSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sort(fixedIndex, fixedIndex + count - 1);
            return TmphDoubleSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (double* startIndex, double* endIndex)
        {
            do
            {
                double leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                double* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                double value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void SortDesc(double[] values)
        {
            if (values.Length > 1)
            {
                fixed (double* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static double[] GetSortDesc(double[] values)
        {
            if (values.Length != 0)
            {
                double[] newValue = new double[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(double));
                fixed (double* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void SortDesc(double[] values, int startIndex, int count)
        {
            fixed (double* valueFixed = values)
            {
                double* start = valueFixed + startIndex;
                sortDesc(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static double[] GetSortDesc
            (double[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                double[] newValues = new double[count];
                Buffer.BlockCopy(values, startIndex * sizeof(double), newValues, 0, count * sizeof(double));
                fixed (double* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return TmphNullValue<double>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        public unsafe static void sortDesc
            (TmphDoubleSortIndex* startIndex, TmphDoubleSortIndex* endIndex)
        {
            do
            {
                TmphDoubleSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                TmphDoubleSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                TmphDoubleSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                double value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphDoubleSortIndex));
            TmphPointer data = pool.Get(values.Length * sizeof(TmphDoubleSortIndex));
            try
            {
                return getSortDesc(values, getKey, (TmphDoubleSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey, TmphDoubleSortIndex* fixedIndex)
        {
            TmphDoubleSortIndex.Create(fixedIndex, values, getKey);
            sortDesc(fixedIndex, fixedIndex + values.Length - 1);
            return TmphDoubleSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey, int startIndex, int count)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphDoubleSortIndex));
            TmphPointer data = pool.Get(count * sizeof(TmphDoubleSortIndex));
            try
            {
                return getSortDesc(values, getKey, startIndex, count, (TmphDoubleSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey, int startIndex, int count
            , TmphDoubleSortIndex* fixedIndex)
        {
            TmphDoubleSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sortDesc(fixedIndex, fixedIndex + count - 1);
            return TmphDoubleSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (float* startIndex, float* endIndex)
        {
            do
            {
                float leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                float* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                float value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void Sort(float[] values)
        {
            if (values.Length > 1)
            {
                fixed (float* valueFixed = values)
                {
                    sort(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static float[] GetSort(float[] values)
        {
            if (values.Length != 0)
            {
                float[] newValue = new float[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(float));
                fixed (float* newValueFixed = newValue, valueFixed = values)
                {
                    sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void Sort(float[] values, int startIndex, int count)
        {
            fixed (float* valueFixed = values)
            {
                float* start = valueFixed + startIndex;
                sort(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static float[] GetSort
            (float[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                float[] newValues = new float[count];
                Buffer.BlockCopy(values, startIndex * sizeof(float), newValues, 0, count * sizeof(float));
                fixed (float* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sort(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return TmphNullValue<float>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        public unsafe static void sort
            (TmphFloatSortIndex* startIndex, TmphFloatSortIndex* endIndex)
        {
            do
            {
                TmphFloatSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                TmphFloatSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                TmphFloatSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                float value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSort<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphFloatSortIndex));
            TmphPointer data = pool.Get(values.Length * sizeof(TmphFloatSortIndex));
            try
            {
                return getSort(values, getKey, (TmphFloatSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSort<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey, TmphFloatSortIndex* fixedIndex)
        {
            TmphFloatSortIndex.Create(fixedIndex, values, getKey);
            sort(fixedIndex, fixedIndex + values.Length - 1);
            return TmphFloatSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSort<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey, int startIndex, int count)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphFloatSortIndex));
            TmphPointer data = pool.Get(count * sizeof(TmphFloatSortIndex));
            try
            {
                return getSort(values, getKey, startIndex, count, (TmphFloatSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSort<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey, int startIndex, int count
            , TmphFloatSortIndex* fixedIndex)
        {
            TmphFloatSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sort(fixedIndex, fixedIndex + count - 1);
            return TmphFloatSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (float* startIndex, float* endIndex)
        {
            do
            {
                float leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                float* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                float value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void SortDesc(float[] values)
        {
            if (values.Length > 1)
            {
                fixed (float* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static float[] GetSortDesc(float[] values)
        {
            if (values.Length != 0)
            {
                float[] newValue = new float[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(float));
                fixed (float* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void SortDesc(float[] values, int startIndex, int count)
        {
            fixed (float* valueFixed = values)
            {
                float* start = valueFixed + startIndex;
                sortDesc(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static float[] GetSortDesc
            (float[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                float[] newValues = new float[count];
                Buffer.BlockCopy(values, startIndex * sizeof(float), newValues, 0, count * sizeof(float));
                fixed (float* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return TmphNullValue<float>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        public unsafe static void sortDesc
            (TmphFloatSortIndex* startIndex, TmphFloatSortIndex* endIndex)
        {
            do
            {
                TmphFloatSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                TmphFloatSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                TmphFloatSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                float value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphFloatSortIndex));
            TmphPointer data = pool.Get(values.Length * sizeof(TmphFloatSortIndex));
            try
            {
                return getSortDesc(values, getKey, (TmphFloatSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey, TmphFloatSortIndex* fixedIndex)
        {
            TmphFloatSortIndex.Create(fixedIndex, values, getKey);
            sortDesc(fixedIndex, fixedIndex + values.Length - 1);
            return TmphFloatSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey, int startIndex, int count)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphFloatSortIndex));
            TmphPointer data = pool.Get(count * sizeof(TmphFloatSortIndex));
            try
            {
                return getSortDesc(values, getKey, startIndex, count, (TmphFloatSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey, int startIndex, int count
            , TmphFloatSortIndex* fixedIndex)
        {
            TmphFloatSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sortDesc(fixedIndex, fixedIndex + count - 1);
            return TmphFloatSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (DateTime* startIndex, DateTime* endIndex)
        {
            do
            {
                DateTime leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                DateTime* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                DateTime value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void Sort(DateTime[] values)
        {
            if (values.Length > 1)
            {
                fixed (DateTime* valueFixed = values)
                {
                    sort(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static DateTime[] GetSort(DateTime[] values)
        {
            if (values.Length != 0)
            {
                DateTime[] newValue = new DateTime[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(DateTime));
                fixed (DateTime* newValueFixed = newValue, valueFixed = values)
                {
                    sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void Sort(DateTime[] values, int startIndex, int count)
        {
            fixed (DateTime* valueFixed = values)
            {
                DateTime* start = valueFixed + startIndex;
                sort(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static DateTime[] GetSort
            (DateTime[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                DateTime[] newValues = new DateTime[count];
                Buffer.BlockCopy(values, startIndex * sizeof(DateTime), newValues, 0, count * sizeof(DateTime));
                fixed (DateTime* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sort(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return TmphNullValue<DateTime>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        public unsafe static void sort
            (TmphDateTimeSortIndex* startIndex, TmphDateTimeSortIndex* endIndex)
        {
            do
            {
                TmphDateTimeSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                TmphDateTimeSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                TmphDateTimeSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                DateTime value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSort<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphDateTimeSortIndex));
            TmphPointer data = pool.Get(values.Length * sizeof(TmphDateTimeSortIndex));
            try
            {
                return getSort(values, getKey, (TmphDateTimeSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSort<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey, TmphDateTimeSortIndex* fixedIndex)
        {
            TmphDateTimeSortIndex.Create(fixedIndex, values, getKey);
            sort(fixedIndex, fixedIndex + values.Length - 1);
            return TmphDateTimeSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSort<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey, int startIndex, int count)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphDateTimeSortIndex));
            TmphPointer data = pool.Get(count * sizeof(TmphDateTimeSortIndex));
            try
            {
                return getSort(values, getKey, startIndex, count, (TmphDateTimeSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSort<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey, int startIndex, int count
            , TmphDateTimeSortIndex* fixedIndex)
        {
            TmphDateTimeSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sort(fixedIndex, fixedIndex + count - 1);
            return TmphDateTimeSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (DateTime* startIndex, DateTime* endIndex)
        {
            do
            {
                DateTime leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                DateTime* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                DateTime value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        public unsafe static void SortDesc(DateTime[] values)
        {
            if (values.Length > 1)
            {
                fixed (DateTime* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static DateTime[] GetSortDesc(DateTime[] values)
        {
            if (values.Length != 0)
            {
                DateTime[] newValue = new DateTime[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(DateTime));
                fixed (DateTime* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void SortDesc(DateTime[] values, int startIndex, int count)
        {
            fixed (DateTime* valueFixed = values)
            {
                DateTime* start = valueFixed + startIndex;
                sortDesc(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static DateTime[] GetSortDesc
            (DateTime[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                DateTime[] newValues = new DateTime[count];
                Buffer.BlockCopy(values, startIndex * sizeof(DateTime), newValues, 0, count * sizeof(DateTime));
                fixed (DateTime* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return TmphNullValue<DateTime>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        public unsafe static void sortDesc
            (TmphDateTimeSortIndex* startIndex, TmphDateTimeSortIndex* endIndex)
        {
            do
            {
                TmphDateTimeSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                TmphDateTimeSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                TmphDateTimeSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                DateTime value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphDateTimeSortIndex));
            TmphPointer data = pool.Get(values.Length * sizeof(TmphDateTimeSortIndex));
            try
            {
                return getSortDesc(values, getKey, (TmphDateTimeSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey, TmphDateTimeSortIndex* fixedIndex)
        {
            TmphDateTimeSortIndex.Create(fixedIndex, values, getKey);
            sortDesc(fixedIndex, fixedIndex + values.Length - 1);
            return TmphDateTimeSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey, int startIndex, int count)
        {
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphDateTimeSortIndex));
            TmphPointer data = pool.Get(count * sizeof(TmphDateTimeSortIndex));
            try
            {
                return getSortDesc(values, getKey, startIndex, count, (TmphDateTimeSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey, int startIndex, int count
            , TmphDateTimeSortIndex* fixedIndex)
        {
            TmphDateTimeSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sortDesc(fixedIndex, fixedIndex + count - 1);
            return TmphDateTimeSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static double[] sortDesc(this double[] array)
        {
            if (array != null)
            {
                Laurent.Lee.CLB.Algorithm.TmphQuickSort.SortDesc(array);
                return array;
            }
            return TmphNullValue<double>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static double[] getSortDesc(this double[] array)
        {
            if (array != null)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetSortDesc(array);
            }
            return TmphNullValue<double>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static TValueType[] getSortDesc<TValueType>
            (this TValueType[] array, Func<TValueType, double> getKey)
        {
            if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
            if (array != null)
            {
                if (array.Length > 1) return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetSortDesc(array, getKey);
                if (array.Length != 0) return new TValueType[] { array[0] };
            }
            return TmphNullValue<TValueType>.Array;
        }
    }
    
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static TmphSubArray<double> sortDesc(this TmphSubArray<double> array)
        {
            if (array.Count > 1) Laurent.Lee.CLB.Algorithm.TmphQuickSort.SortDesc(array.Array, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static double[] getSortDesc(this TmphSubArray<double> array)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetSortDesc(array.Array, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static TValueType[] getSortDesc<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, double> getKey)
        {
            if (array.Count > 1) return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetSortDesc(array.Array, getKey, array.StartIndex, array.Count);
            return array.Count == 0 ? TmphNullValue<TValueType>.Array : new TValueType[] { array.Array[array.StartIndex] };
        }
    }
}
namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static float[] sort(this float[] array)
        {
            if (array != null)
            {
                Laurent.Lee.CLB.Algorithm.TmphQuickSort.Sort(array);
                return array;
            }
            return TmphNullValue<float>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static float[] getSort(this float[] array)
        {
            if (array != null)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetSort(array);
            }
            return TmphNullValue<float>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static TValueType[] getSort<TValueType>
            (this TValueType[] array, Func<TValueType, float> getKey)
        {
            if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
            if (array != null)
            {
                if (array.Length > 1) return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetSort(array, getKey);
                if (array.Length != 0) return new TValueType[] { array[0] };
            }
            return TmphNullValue<TValueType>.Array;
        }
    }
    
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static TmphSubArray<float> sort(this TmphSubArray<float> array)
        {
            if (array.Count > 1) Laurent.Lee.CLB.Algorithm.TmphQuickSort.Sort(array.Array, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static float[] getSort(this TmphSubArray<float> array)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetSort(array.Array, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static TValueType[] getSort<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, float> getKey)
        {
            if (array.Count > 1) return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetSort(array.Array, getKey, array.StartIndex, array.Count);
            return array.Count == 0 ? TmphNullValue<TValueType>.Array : new TValueType[] { array.Array[array.StartIndex] };
        }
    }
}
namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static float[] sortDesc(this float[] array)
        {
            if (array != null)
            {
                Laurent.Lee.CLB.Algorithm.TmphQuickSort.SortDesc(array);
                return array;
            }
            return TmphNullValue<float>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static float[] getSortDesc(this float[] array)
        {
            if (array != null)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetSortDesc(array);
            }
            return TmphNullValue<float>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static TValueType[] getSortDesc<TValueType>
            (this TValueType[] array, Func<TValueType, float> getKey)
        {
            if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
            if (array != null)
            {
                if (array.Length > 1) return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetSortDesc(array, getKey);
                if (array.Length != 0) return new TValueType[] { array[0] };
            }
            return TmphNullValue<TValueType>.Array;
        }
    }
    
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        public static TmphSubArray<float> sortDesc(this TmphSubArray<float> array)
        {
            if (array.Count > 1) Laurent.Lee.CLB.Algorithm.TmphQuickSort.SortDesc(array.Array, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static float[] getSortDesc(this TmphSubArray<float> array)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetSortDesc(array.Array, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        public static TValueType[] getSortDesc<TValueType>(this TmphSubArray<TValueType> array, Func<TValueType, float> getKey)
        {
            if (array.Count > 1) return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetSortDesc(array.Array, getKey, array.StartIndex, array.Count);
            return array.Count == 0 ? TmphNullValue<TValueType>.Array : new TValueType[] { array.Array[array.StartIndex] };
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        public unsafe struct TmphUlongRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public ulong* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public ulong* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(ulong* startIndex, ulong* endIndex)
            {
                do
                {
                    ulong leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    ulong* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    ulong value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<ulong> RangeSortDesc
            (ulong[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (ulong* valueFixed = values)
                {
                    new TmphUlongRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return TmphSubArray<ulong>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(TmphSubArray<ulong>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<ulong> GetRangeSortDesc
            (ulong[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                ulong[] newValues = new ulong[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(ulong));
                fixed (ulong* newValueFixed = newValues, valueFixed = values)
                {
                    new TmphUlongRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return TmphSubArray<ulong>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(TmphSubArray<ulong>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<ulong> RangeSortDesc
            (ulong[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (ulong* valueFixed = values)
                    {
                        ulong* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new TmphUlongRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return TmphSubArray<ulong>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(TmphSubArray<ulong>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<ulong> GetRangeSortDesc
            (ulong[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    ulong[] newValues = new ulong[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(ulong), newValues, 0, count * sizeof(ulong));
                    fixed (ulong* newValueFixed = newValues, valueFixed = values)
                    {
                        new TmphUlongRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return TmphSubArray<ulong>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(TmphSubArray<ulong>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        public unsafe struct TmphUlongRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public ulongSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public ulongSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(ulongSortIndex* startIndex, ulongSortIndex* endIndex)
            {
                do
                {
                    ulongSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    ulongSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    ulongSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    ulong value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, ulong> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(ulongSortIndex));
                TmphPointer data = pool.Get(values.Length * sizeof(ulongSortIndex));
                try
                {
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, (ulongSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, ulong> getKey, int skipCount, int getCount
            , ulongSortIndex* fixedIndex)
        {
            ulongSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSortDesc<TValueType>
            (TValueType[] values, int skipCount, int getCount, ulongSortIndex* fixedIndex)
        {
            new TmphUlongRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            TValueType[] newValues = new TValueType[getCount];
            ulongSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSortDesc<TValueType>
            (TValueType[] values, ulongSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) TmphLog.Error.Throw(TmphLog.TmphExceptionType.IndexOutOfRange);
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (ulongSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSortDesc<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, ulong> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                    TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(ulongSortIndex));
                    TmphPointer data = pool.Get(count * sizeof(ulongSortIndex));
                    try
                    {
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (ulongSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSortDesc<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, ulong> getKey, int skipCount, int getCount
            , ulongSortIndex* fixedIndex)
        {
            ulongSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new TmphUlongRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            TValueType[] newValues = new TValueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<ulong> rangeSortDesc
            (this ulong[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<ulong> getRangeSortDesc
            (this ulong[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSortDesc<TValueType>
            (this TValueType[] array, Func<TValueType, ulong> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<ulong> rangeSortDesc
            (this ulong[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<ulong> getRangeSortDesc
            (this ulong[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSortDesc<TValueType>
            (this TValueType[] array, int startIndex, int count, Func<TValueType, ulong> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<ulong> pageSortDesc
            (this ulong[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TValueType[] getPageSortDesc<TValueType>
            (this TValueType[] array, Func<TValueType, ulong> getKey, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<ulong> getPageSortDesc
            (this ulong[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<ulong> rangeSortDesc
            (this TmphSubArray<ulong> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<ulong>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<ulong> getRangeSortDesc
            (this TmphSubArray<ulong> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<ulong>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSortDesc<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, ulong> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc
                    (array.Array, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<ulong> pageSortDesc
            (this TmphSubArray<ulong> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<ulong>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<ulong> getPageSortDesc
            (this TmphSubArray<ulong> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<ulong>);
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        public unsafe struct longRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public long* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public long* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(long* startIndex, long* endIndex)
            {
                do
                {
                    long leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    long* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    long value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<long> RangeSort
            (long[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (long* valueFixed = values)
                {
                    new longRangeSorter
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return TmphSubArray<long>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(TmphSubArray<long>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<long> GetRangeSort
            (long[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                long[] newValues = new long[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(long));
                fixed (long* newValueFixed = newValues, valueFixed = values)
                {
                    new longRangeSorter
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return TmphSubArray<long>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(TmphSubArray<long>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<long> RangeSort
            (long[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (long* valueFixed = values)
                    {
                        long* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new longRangeSorter
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return TmphSubArray<long>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(TmphSubArray<long>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<long> GetRangeSort
            (long[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    long[] newValues = new long[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(long), newValues, 0, count * sizeof(long));
                    fixed (long* newValueFixed = newValues, valueFixed = values)
                    {
                        new longRangeSorter
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return TmphSubArray<long>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(TmphSubArray<long>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        public unsafe struct longRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public TmphLongSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public TmphLongSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(TmphLongSortIndex* startIndex, TmphLongSortIndex* endIndex)
            {
                do
                {
                    TmphLongSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    TmphLongSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    TmphLongSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    long value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSort<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphLongSortIndex));
                TmphPointer data = pool.Get(values.Length * sizeof(TmphLongSortIndex));
                try
                {
                    return getRangeSort(values, getKey, range.SkipCount, getCount, (TmphLongSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSort<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey, int skipCount, int getCount
            , TmphLongSortIndex* fixedIndex)
        {
            TmphLongSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSort(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSort<TValueType>
            (TValueType[] values, int skipCount, int getCount, TmphLongSortIndex* fixedIndex)
        {
            new longRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            TValueType[] newValues = new TValueType[getCount];
            TmphLongSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSort<TValueType>
            (TValueType[] values, TmphLongSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) TmphLog.Error.Throw(TmphLog.TmphExceptionType.IndexOutOfRange);
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (TmphLongSortIndex* fixedIndex = indexs) return getRangeSort(values, skipCount, getCount, fixedIndex);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSort<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, long> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                    TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphLongSortIndex));
                    TmphPointer data = pool.Get(count * sizeof(TmphLongSortIndex));
                    try
                    {
                        return getRangeSort
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (TmphLongSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSort<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, long> getKey, int skipCount, int getCount
            , TmphLongSortIndex* fixedIndex)
        {
            TmphLongSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new longRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            TValueType[] newValues = new TValueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<long> rangeSort
            (this long[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<long> getRangeSort
            (this long[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSort<TValueType>
            (this TValueType[] array, Func<TValueType, long> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<long> rangeSort
            (this long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<long> getRangeSort
            (this long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSort<TValueType>
            (this TValueType[] array, int startIndex, int count, Func<TValueType, long> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<long> pageSort
            (this long[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TValueType[] getPageSort<TValueType>
            (this TValueType[] array, Func<TValueType, long> getKey, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<long> getPageSort
            (this long[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<long> rangeSort
            (this TmphSubArray<long> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<long>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<long> getRangeSort
            (this TmphSubArray<long> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<long>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSort<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, long> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort
                    (array.Array, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<long> pageSort
            (this TmphSubArray<long> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<long>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<long> getPageSort
            (this TmphSubArray<long> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<long>);
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        public unsafe struct longRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public long* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public long* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(long* startIndex, long* endIndex)
            {
                do
                {
                    long leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    long* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    long value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<long> RangeSortDesc
            (long[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (long* valueFixed = values)
                {
                    new longRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return TmphSubArray<long>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(TmphSubArray<long>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<long> GetRangeSortDesc
            (long[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                long[] newValues = new long[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(long));
                fixed (long* newValueFixed = newValues, valueFixed = values)
                {
                    new longRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return TmphSubArray<long>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(TmphSubArray<long>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<long> RangeSortDesc
            (long[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (long* valueFixed = values)
                    {
                        long* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new longRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return TmphSubArray<long>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(TmphSubArray<long>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<long> GetRangeSortDesc
            (long[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    long[] newValues = new long[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(long), newValues, 0, count * sizeof(long));
                    fixed (long* newValueFixed = newValues, valueFixed = values)
                    {
                        new longRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return TmphSubArray<long>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(TmphSubArray<long>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        public unsafe struct longRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public TmphLongSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public TmphLongSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(TmphLongSortIndex* startIndex, TmphLongSortIndex* endIndex)
            {
                do
                {
                    TmphLongSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    TmphLongSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    TmphLongSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    long value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphLongSortIndex));
                TmphPointer data = pool.Get(values.Length * sizeof(TmphLongSortIndex));
                try
                {
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, (TmphLongSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey, int skipCount, int getCount
            , TmphLongSortIndex* fixedIndex)
        {
            TmphLongSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSortDesc<TValueType>
            (TValueType[] values, int skipCount, int getCount, TmphLongSortIndex* fixedIndex)
        {
            new longRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            TValueType[] newValues = new TValueType[getCount];
            TmphLongSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSortDesc<TValueType>
            (TValueType[] values, TmphLongSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) TmphLog.Error.Throw(TmphLog.TmphExceptionType.IndexOutOfRange);
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (TmphLongSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSortDesc<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, long> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                    TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphLongSortIndex));
                    TmphPointer data = pool.Get(count * sizeof(TmphLongSortIndex));
                    try
                    {
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (TmphLongSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSortDesc<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, long> getKey, int skipCount, int getCount
            , TmphLongSortIndex* fixedIndex)
        {
            TmphLongSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new longRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            TValueType[] newValues = new TValueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<long> rangeSortDesc
            (this long[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<long> getRangeSortDesc
            (this long[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSortDesc<TValueType>
            (this TValueType[] array, Func<TValueType, long> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<long> rangeSortDesc
            (this long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<long> getRangeSortDesc
            (this long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSortDesc<TValueType>
            (this TValueType[] array, int startIndex, int count, Func<TValueType, long> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<long> pageSortDesc
            (this long[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TValueType[] getPageSortDesc<TValueType>
            (this TValueType[] array, Func<TValueType, long> getKey, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<long> getPageSortDesc
            (this long[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<long> rangeSortDesc
            (this TmphSubArray<long> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<long>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<long> getRangeSortDesc
            (this TmphSubArray<long> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<long>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSortDesc<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, long> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc
                    (array.Array, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<long> pageSortDesc
            (this TmphSubArray<long> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<long>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<long> getPageSortDesc
            (this TmphSubArray<long> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<long>);
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        public unsafe struct uintRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public uint* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public uint* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(uint* startIndex, uint* endIndex)
            {
                do
                {
                    uint leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    uint* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    uint value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<uint> RangeSort
            (uint[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (uint* valueFixed = values)
                {
                    new uintRangeSorter
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return TmphSubArray<uint>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(TmphSubArray<uint>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<uint> GetRangeSort
            (uint[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                uint[] newValues = new uint[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(uint));
                fixed (uint* newValueFixed = newValues, valueFixed = values)
                {
                    new uintRangeSorter
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return TmphSubArray<uint>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(TmphSubArray<uint>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<uint> RangeSort
            (uint[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (uint* valueFixed = values)
                    {
                        uint* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new uintRangeSorter
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return TmphSubArray<uint>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(TmphSubArray<uint>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<uint> GetRangeSort
            (uint[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    uint[] newValues = new uint[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(uint), newValues, 0, count * sizeof(uint));
                    fixed (uint* newValueFixed = newValues, valueFixed = values)
                    {
                        new uintRangeSorter
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return TmphSubArray<uint>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(TmphSubArray<uint>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        public unsafe struct uintRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public TmphUintSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public TmphUintSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(TmphUintSortIndex* startIndex, TmphUintSortIndex* endIndex)
            {
                do
                {
                    TmphUintSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    TmphUintSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    TmphUintSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    uint value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSort<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphUintSortIndex));
                TmphPointer data = pool.Get(values.Length * sizeof(TmphUintSortIndex));
                try
                {
                    return getRangeSort(values, getKey, range.SkipCount, getCount, (TmphUintSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSort<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey, int skipCount, int getCount
            , TmphUintSortIndex* fixedIndex)
        {
            TmphUintSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSort(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSort<TValueType>
            (TValueType[] values, int skipCount, int getCount, TmphUintSortIndex* fixedIndex)
        {
            new uintRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            TValueType[] newValues = new TValueType[getCount];
            TmphUintSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSort<TValueType>
            (TValueType[] values, TmphUintSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) TmphLog.Error.Throw(TmphLog.TmphExceptionType.IndexOutOfRange);
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (TmphUintSortIndex* fixedIndex = indexs) return getRangeSort(values, skipCount, getCount, fixedIndex);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSort<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, uint> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                    TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphUintSortIndex));
                    TmphPointer data = pool.Get(count * sizeof(TmphUintSortIndex));
                    try
                    {
                        return getRangeSort
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (TmphUintSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSort<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, uint> getKey, int skipCount, int getCount
            , TmphUintSortIndex* fixedIndex)
        {
            TmphUintSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new uintRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            TValueType[] newValues = new TValueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<uint> rangeSort
            (this uint[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<uint> getRangeSort
            (this uint[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSort<TValueType>
            (this TValueType[] array, Func<TValueType, uint> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<uint> rangeSort
            (this uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<uint> getRangeSort
            (this uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSort<TValueType>
            (this TValueType[] array, int startIndex, int count, Func<TValueType, uint> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<uint> pageSort
            (this uint[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TValueType[] getPageSort<TValueType>
            (this TValueType[] array, Func<TValueType, uint> getKey, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<uint> getPageSort
            (this uint[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<uint> rangeSort
            (this TmphSubArray<uint> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<uint>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<uint> getRangeSort
            (this TmphSubArray<uint> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<uint>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSort<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, uint> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort
                    (array.Array, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<uint> pageSort
            (this TmphSubArray<uint> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<uint>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<uint> getPageSort
            (this TmphSubArray<uint> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<uint>);
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        public unsafe struct uintRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public uint* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public uint* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(uint* startIndex, uint* endIndex)
            {
                do
                {
                    uint leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    uint* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    uint value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<uint> RangeSortDesc
            (uint[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (uint* valueFixed = values)
                {
                    new uintRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return TmphSubArray<uint>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(TmphSubArray<uint>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<uint> GetRangeSortDesc
            (uint[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                uint[] newValues = new uint[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(uint));
                fixed (uint* newValueFixed = newValues, valueFixed = values)
                {
                    new uintRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return TmphSubArray<uint>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(TmphSubArray<uint>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<uint> RangeSortDesc
            (uint[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (uint* valueFixed = values)
                    {
                        uint* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new uintRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return TmphSubArray<uint>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(TmphSubArray<uint>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<uint> GetRangeSortDesc
            (uint[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    uint[] newValues = new uint[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(uint), newValues, 0, count * sizeof(uint));
                    fixed (uint* newValueFixed = newValues, valueFixed = values)
                    {
                        new uintRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return TmphSubArray<uint>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(TmphSubArray<uint>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        public unsafe struct uintRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public TmphUintSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public TmphUintSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(TmphUintSortIndex* startIndex, TmphUintSortIndex* endIndex)
            {
                do
                {
                    TmphUintSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    TmphUintSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    TmphUintSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    uint value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphUintSortIndex));
                TmphPointer data = pool.Get(values.Length * sizeof(TmphUintSortIndex));
                try
                {
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, (TmphUintSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey, int skipCount, int getCount
            , TmphUintSortIndex* fixedIndex)
        {
            TmphUintSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSortDesc<TValueType>
            (TValueType[] values, int skipCount, int getCount, TmphUintSortIndex* fixedIndex)
        {
            new uintRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            TValueType[] newValues = new TValueType[getCount];
            TmphUintSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSortDesc<TValueType>
            (TValueType[] values, TmphUintSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) TmphLog.Error.Throw(TmphLog.TmphExceptionType.IndexOutOfRange);
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (TmphUintSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSortDesc<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, uint> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                    TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphUintSortIndex));
                    TmphPointer data = pool.Get(count * sizeof(TmphUintSortIndex));
                    try
                    {
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (TmphUintSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSortDesc<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, uint> getKey, int skipCount, int getCount
            , TmphUintSortIndex* fixedIndex)
        {
            TmphUintSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new uintRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            TValueType[] newValues = new TValueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<uint> rangeSortDesc
            (this uint[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<uint> getRangeSortDesc
            (this uint[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSortDesc<TValueType>
            (this TValueType[] array, Func<TValueType, uint> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<uint> rangeSortDesc
            (this uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<uint> getRangeSortDesc
            (this uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSortDesc<TValueType>
            (this TValueType[] array, int startIndex, int count, Func<TValueType, uint> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<uint> pageSortDesc
            (this uint[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TValueType[] getPageSortDesc<TValueType>
            (this TValueType[] array, Func<TValueType, uint> getKey, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<uint> getPageSortDesc
            (this uint[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<uint> rangeSortDesc
            (this TmphSubArray<uint> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<uint>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<uint> getRangeSortDesc
            (this TmphSubArray<uint> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<uint>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSortDesc<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, uint> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc
                    (array.Array, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<uint> pageSortDesc
            (this TmphSubArray<uint> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<uint>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<uint> getPageSortDesc
            (this TmphSubArray<uint> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<uint>);
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        public unsafe struct intRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public int* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public int* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(int* startIndex, int* endIndex)
            {
                do
                {
                    int leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    int* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    int value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<int> RangeSort
            (int[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (int* valueFixed = values)
                {
                    new intRangeSorter
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return TmphSubArray<int>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(TmphSubArray<int>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<int> GetRangeSort
            (int[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                int[] newValues = new int[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(int));
                fixed (int* newValueFixed = newValues, valueFixed = values)
                {
                    new intRangeSorter
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return TmphSubArray<int>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(TmphSubArray<int>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<int> RangeSort
            (int[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (int* valueFixed = values)
                    {
                        int* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new intRangeSorter
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return TmphSubArray<int>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(TmphSubArray<int>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<int> GetRangeSort
            (int[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    int[] newValues = new int[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(int), newValues, 0, count * sizeof(int));
                    fixed (int* newValueFixed = newValues, valueFixed = values)
                    {
                        new intRangeSorter
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return TmphSubArray<int>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(TmphSubArray<int>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        public unsafe struct intRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public TmphIntSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public TmphIntSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(TmphIntSortIndex* startIndex, TmphIntSortIndex* endIndex)
            {
                do
                {
                    TmphIntSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    TmphIntSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    TmphIntSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    int value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSort<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphIntSortIndex));
                TmphPointer data = pool.Get(values.Length * sizeof(TmphIntSortIndex));
                try
                {
                    return getRangeSort(values, getKey, range.SkipCount, getCount, (TmphIntSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSort<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey, int skipCount, int getCount
            , TmphIntSortIndex* fixedIndex)
        {
            TmphIntSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSort(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSort<TValueType>
            (TValueType[] values, int skipCount, int getCount, TmphIntSortIndex* fixedIndex)
        {
            new intRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            TValueType[] newValues = new TValueType[getCount];
            TmphIntSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSort<TValueType>
            (TValueType[] values, TmphIntSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) TmphLog.Error.Throw(TmphLog.TmphExceptionType.IndexOutOfRange);
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (TmphIntSortIndex* fixedIndex = indexs) return getRangeSort(values, skipCount, getCount, fixedIndex);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSort<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, int> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                    TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphIntSortIndex));
                    TmphPointer data = pool.Get(count * sizeof(TmphIntSortIndex));
                    try
                    {
                        return getRangeSort
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (TmphIntSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSort<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, int> getKey, int skipCount, int getCount
            , TmphIntSortIndex* fixedIndex)
        {
            TmphIntSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new intRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            TValueType[] newValues = new TValueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<int> rangeSort
            (this int[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<int> getRangeSort
            (this int[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSort<TValueType>
            (this TValueType[] array, Func<TValueType, int> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<int> rangeSort
            (this int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<int> getRangeSort
            (this int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSort<TValueType>
            (this TValueType[] array, int startIndex, int count, Func<TValueType, int> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<int> pageSort
            (this int[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TValueType[] getPageSort<TValueType>
            (this TValueType[] array, Func<TValueType, int> getKey, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<int> getPageSort
            (this int[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<int> rangeSort
            (this TmphSubArray<int> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<int>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<int> getRangeSort
            (this TmphSubArray<int> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<int>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSort<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, int> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort
                    (array.Array, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<int> pageSort
            (this TmphSubArray<int> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<int>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<int> getPageSort
            (this TmphSubArray<int> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<int>);
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        public unsafe struct intRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public int* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public int* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(int* startIndex, int* endIndex)
            {
                do
                {
                    int leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    int* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    int value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<int> RangeSortDesc
            (int[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (int* valueFixed = values)
                {
                    new intRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return TmphSubArray<int>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(TmphSubArray<int>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<int> GetRangeSortDesc
            (int[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                int[] newValues = new int[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(int));
                fixed (int* newValueFixed = newValues, valueFixed = values)
                {
                    new intRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return TmphSubArray<int>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(TmphSubArray<int>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<int> RangeSortDesc
            (int[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (int* valueFixed = values)
                    {
                        int* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new intRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return TmphSubArray<int>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(TmphSubArray<int>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<int> GetRangeSortDesc
            (int[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    int[] newValues = new int[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(int), newValues, 0, count * sizeof(int));
                    fixed (int* newValueFixed = newValues, valueFixed = values)
                    {
                        new intRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return TmphSubArray<int>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(TmphSubArray<int>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        public unsafe struct intRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public TmphIntSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public TmphIntSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(TmphIntSortIndex* startIndex, TmphIntSortIndex* endIndex)
            {
                do
                {
                    TmphIntSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    TmphIntSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    TmphIntSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    int value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphIntSortIndex));
                TmphPointer data = pool.Get(values.Length * sizeof(TmphIntSortIndex));
                try
                {
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, (TmphIntSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey, int skipCount, int getCount
            , TmphIntSortIndex* fixedIndex)
        {
            TmphIntSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSortDesc<TValueType>
            (TValueType[] values, int skipCount, int getCount, TmphIntSortIndex* fixedIndex)
        {
            new intRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            TValueType[] newValues = new TValueType[getCount];
            TmphIntSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSortDesc<TValueType>
            (TValueType[] values, TmphIntSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) TmphLog.Error.Throw(TmphLog.TmphExceptionType.IndexOutOfRange);
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (TmphIntSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSortDesc<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, int> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                    TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphIntSortIndex));
                    TmphPointer data = pool.Get(count * sizeof(TmphIntSortIndex));
                    try
                    {
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (TmphIntSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSortDesc<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, int> getKey, int skipCount, int getCount
            , TmphIntSortIndex* fixedIndex)
        {
            TmphIntSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new intRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            TValueType[] newValues = new TValueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<int> rangeSortDesc
            (this int[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<int> getRangeSortDesc
            (this int[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSortDesc<TValueType>
            (this TValueType[] array, Func<TValueType, int> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<int> rangeSortDesc
            (this int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<int> getRangeSortDesc
            (this int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSortDesc<TValueType>
            (this TValueType[] array, int startIndex, int count, Func<TValueType, int> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<int> pageSortDesc
            (this int[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TValueType[] getPageSortDesc<TValueType>
            (this TValueType[] array, Func<TValueType, int> getKey, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<int> getPageSortDesc
            (this int[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<int> rangeSortDesc
            (this TmphSubArray<int> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<int>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<int> getRangeSortDesc
            (this TmphSubArray<int> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<int>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSortDesc<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, int> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc
                    (array.Array, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<int> pageSortDesc
            (this TmphSubArray<int> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<int>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<int> getPageSortDesc
            (this TmphSubArray<int> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<int>);
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        public unsafe struct doubleRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public double* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public double* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(double* startIndex, double* endIndex)
            {
                do
                {
                    double leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    double* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    double value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<double> RangeSort
            (double[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (double* valueFixed = values)
                {
                    new doubleRangeSorter
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return TmphSubArray<double>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(TmphSubArray<double>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<double> GetRangeSort
            (double[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                double[] newValues = new double[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(double));
                fixed (double* newValueFixed = newValues, valueFixed = values)
                {
                    new doubleRangeSorter
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return TmphSubArray<double>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(TmphSubArray<double>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<double> RangeSort
            (double[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (double* valueFixed = values)
                    {
                        double* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new doubleRangeSorter
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return TmphSubArray<double>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(TmphSubArray<double>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<double> GetRangeSort
            (double[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    double[] newValues = new double[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(double), newValues, 0, count * sizeof(double));
                    fixed (double* newValueFixed = newValues, valueFixed = values)
                    {
                        new doubleRangeSorter
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return TmphSubArray<double>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(TmphSubArray<double>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        public unsafe struct TmphDoubleRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public TmphDoubleSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public TmphDoubleSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(TmphDoubleSortIndex* startIndex, TmphDoubleSortIndex* endIndex)
            {
                do
                {
                    TmphDoubleSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    TmphDoubleSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    TmphDoubleSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    double value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSort<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphDoubleSortIndex));
                TmphPointer data = pool.Get(values.Length * sizeof(TmphDoubleSortIndex));
                try
                {
                    return getRangeSort(values, getKey, range.SkipCount, getCount, (TmphDoubleSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSort<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey, int skipCount, int getCount
            , TmphDoubleSortIndex* fixedIndex)
        {
            TmphDoubleSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSort(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSort<TValueType>
            (TValueType[] values, int skipCount, int getCount, TmphDoubleSortIndex* fixedIndex)
        {
            new TmphDoubleRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            TValueType[] newValues = new TValueType[getCount];
            TmphDoubleSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSort<TValueType>
            (TValueType[] values, TmphDoubleSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) TmphLog.Error.Throw(TmphLog.TmphExceptionType.IndexOutOfRange);
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (TmphDoubleSortIndex* fixedIndex = indexs) return getRangeSort(values, skipCount, getCount, fixedIndex);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSort<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, double> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                    TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphDoubleSortIndex));
                    TmphPointer data = pool.Get(count * sizeof(TmphDoubleSortIndex));
                    try
                    {
                        return getRangeSort
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (TmphDoubleSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSort<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, double> getKey, int skipCount, int getCount
            , TmphDoubleSortIndex* fixedIndex)
        {
            TmphDoubleSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new TmphDoubleRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            TValueType[] newValues = new TValueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace Laurent.Lee.CLB.MemoryDatabase.Cache.IndexfastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<double> rangeSort
            (this double[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<double> getRangeSort
            (this double[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSort<TValueType>
            (this TValueType[] array, Func<TValueType, double> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<double> rangeSort
            (this double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<double> getRangeSort
            (this double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSort<TValueType>
            (this TValueType[] array, int startIndex, int count, Func<TValueType, double> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<double> pageSort
            (this double[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TValueType[] getPageSort<TValueType>
            (this TValueType[] array, Func<TValueType, double> getKey, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<double> getPageSort
            (this double[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<double> rangeSort
            (this TmphSubArray<double> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<double>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<double> getRangeSort
            (this TmphSubArray<double> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<double>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSort<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, double> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort
                    (array.Array, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<double> pageSort
            (this TmphSubArray<double> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<double>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<double> getPageSort
            (this TmphSubArray<double> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<double>);
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        public unsafe struct doubleRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public double* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public double* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(double* startIndex, double* endIndex)
            {
                do
                {
                    double leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    double* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    double value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<double> RangeSortDesc
            (double[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (double* valueFixed = values)
                {
                    new doubleRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return TmphSubArray<double>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(TmphSubArray<double>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<double> GetRangeSortDesc
            (double[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                double[] newValues = new double[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(double));
                fixed (double* newValueFixed = newValues, valueFixed = values)
                {
                    new doubleRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return TmphSubArray<double>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(TmphSubArray<double>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<double> RangeSortDesc
            (double[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (double* valueFixed = values)
                    {
                        double* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new doubleRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return TmphSubArray<double>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(TmphSubArray<double>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<double> GetRangeSortDesc
            (double[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    double[] newValues = new double[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(double), newValues, 0, count * sizeof(double));
                    fixed (double* newValueFixed = newValues, valueFixed = values)
                    {
                        new doubleRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return TmphSubArray<double>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(TmphSubArray<double>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        public unsafe struct doubleRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public TmphDoubleSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public TmphDoubleSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(TmphDoubleSortIndex* startIndex, TmphDoubleSortIndex* endIndex)
            {
                do
                {
                    TmphDoubleSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    TmphDoubleSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    TmphDoubleSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    double value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphDoubleSortIndex));
                TmphPointer data = pool.Get(values.Length * sizeof(TmphDoubleSortIndex));
                try
                {
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, (TmphDoubleSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey, int skipCount, int getCount
            , TmphDoubleSortIndex* fixedIndex)
        {
            TmphDoubleSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSortDesc<TValueType>
            (TValueType[] values, int skipCount, int getCount, TmphDoubleSortIndex* fixedIndex)
        {
            new doubleRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            TValueType[] newValues = new TValueType[getCount];
            TmphDoubleSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSortDesc<TValueType>
            (TValueType[] values, TmphDoubleSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) TmphLog.Error.Throw(TmphLog.TmphExceptionType.IndexOutOfRange);
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (TmphDoubleSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSortDesc<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, double> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                    TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphDoubleSortIndex));
                    TmphPointer data = pool.Get(count * sizeof(TmphDoubleSortIndex));
                    try
                    {
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (TmphDoubleSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSortDesc<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, double> getKey, int skipCount, int getCount
            , TmphDoubleSortIndex* fixedIndex)
        {
            TmphDoubleSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new doubleRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            TValueType[] newValues = new TValueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<double> rangeSortDesc
            (this double[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<double> getRangeSortDesc
            (this double[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSortDesc<TValueType>
            (this TValueType[] array, Func<TValueType, double> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<double> rangeSortDesc
            (this double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<double> getRangeSortDesc
            (this double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSortDesc<TValueType>
            (this TValueType[] array, int startIndex, int count, Func<TValueType, double> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<double> pageSortDesc
            (this double[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TValueType[] getPageSortDesc<TValueType>
            (this TValueType[] array, Func<TValueType, double> getKey, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<double> getPageSortDesc
            (this double[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<double> rangeSortDesc
            (this TmphSubArray<double> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<double>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<double> getRangeSortDesc
            (this TmphSubArray<double> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<double>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSortDesc<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, double> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc
                    (array.Array, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<double> pageSortDesc
            (this TmphSubArray<double> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<double>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<double> getPageSortDesc
            (this TmphSubArray<double> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<double>);
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        public unsafe struct floatRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public float* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public float* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(float* startIndex, float* endIndex)
            {
                do
                {
                    float leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    float* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    float value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<float> RangeSort
            (float[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (float* valueFixed = values)
                {
                    new floatRangeSorter
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return TmphSubArray<float>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(TmphSubArray<float>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<float> GetRangeSort
            (float[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                float[] newValues = new float[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(float));
                fixed (float* newValueFixed = newValues, valueFixed = values)
                {
                    new floatRangeSorter
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return TmphSubArray<float>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(TmphSubArray<float>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<float> RangeSort
            (float[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (float* valueFixed = values)
                    {
                        float* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new floatRangeSorter
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return TmphSubArray<float>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(TmphSubArray<float>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<float> GetRangeSort
            (float[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    float[] newValues = new float[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(float), newValues, 0, count * sizeof(float));
                    fixed (float* newValueFixed = newValues, valueFixed = values)
                    {
                        new floatRangeSorter
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return TmphSubArray<float>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(TmphSubArray<float>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        public unsafe struct floatRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public TmphFloatSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public TmphFloatSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(TmphFloatSortIndex* startIndex, TmphFloatSortIndex* endIndex)
            {
                do
                {
                    TmphFloatSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    TmphFloatSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    TmphFloatSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    float value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSort<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphFloatSortIndex));
                TmphPointer data = pool.Get(values.Length * sizeof(TmphFloatSortIndex));
                try
                {
                    return getRangeSort(values, getKey, range.SkipCount, getCount, (TmphFloatSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSort<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey, int skipCount, int getCount
            , TmphFloatSortIndex* fixedIndex)
        {
            TmphFloatSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSort(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSort<TValueType>
            (TValueType[] values, int skipCount, int getCount, TmphFloatSortIndex* fixedIndex)
        {
            new floatRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            TValueType[] newValues = new TValueType[getCount];
            TmphFloatSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSort<TValueType>
            (TValueType[] values, TmphFloatSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) TmphLog.Error.Throw(TmphLog.TmphExceptionType.IndexOutOfRange);
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (TmphFloatSortIndex* fixedIndex = indexs) return getRangeSort(values, skipCount, getCount, fixedIndex);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSort<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, float> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                    TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphFloatSortIndex));
                    TmphPointer data = pool.Get(count * sizeof(TmphFloatSortIndex));
                    try
                    {
                        return getRangeSort
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (TmphFloatSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSort<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, float> getKey, int skipCount, int getCount
            , TmphFloatSortIndex* fixedIndex)
        {
            TmphFloatSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new floatRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            TValueType[] newValues = new TValueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<float> rangeSort
            (this float[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<float> getRangeSort
            (this float[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSort<TValueType>
            (this TValueType[] array, Func<TValueType, float> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<float> rangeSort
            (this float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<float> getRangeSort
            (this float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSort<TValueType>
            (this TValueType[] array, int startIndex, int count, Func<TValueType, float> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<float> pageSort
            (this float[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TValueType[] getPageSort<TValueType>
            (this TValueType[] array, Func<TValueType, float> getKey, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<float> getPageSort
            (this float[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<float> rangeSort
            (this TmphSubArray<float> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<float>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<float> getRangeSort
            (this TmphSubArray<float> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<float>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSort<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, float> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort
                    (array.Array, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<float> pageSort
            (this TmphSubArray<float> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<float>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<float> getPageSort
            (this TmphSubArray<float> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<float>);
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        public unsafe struct floatRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public float* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public float* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(float* startIndex, float* endIndex)
            {
                do
                {
                    float leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    float* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    float value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<float> RangeSortDesc
            (float[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (float* valueFixed = values)
                {
                    new floatRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return TmphSubArray<float>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(TmphSubArray<float>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<float> GetRangeSortDesc
            (float[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                float[] newValues = new float[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(float));
                fixed (float* newValueFixed = newValues, valueFixed = values)
                {
                    new floatRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return TmphSubArray<float>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(TmphSubArray<float>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<float> RangeSortDesc
            (float[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (float* valueFixed = values)
                    {
                        float* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new floatRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return TmphSubArray<float>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(TmphSubArray<float>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<float> GetRangeSortDesc
            (float[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    float[] newValues = new float[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(float), newValues, 0, count * sizeof(float));
                    fixed (float* newValueFixed = newValues, valueFixed = values)
                    {
                        new floatRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return TmphSubArray<float>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(TmphSubArray<float>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        public unsafe struct floatRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public TmphFloatSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public TmphFloatSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(TmphFloatSortIndex* startIndex, TmphFloatSortIndex* endIndex)
            {
                do
                {
                    TmphFloatSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    TmphFloatSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    TmphFloatSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    float value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphFloatSortIndex));
                TmphPointer data = pool.Get(values.Length * sizeof(TmphFloatSortIndex));
                try
                {
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, (TmphFloatSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey, int skipCount, int getCount
            , TmphFloatSortIndex* fixedIndex)
        {
            TmphFloatSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSortDesc<TValueType>
            (TValueType[] values, int skipCount, int getCount, TmphFloatSortIndex* fixedIndex)
        {
            new floatRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            TValueType[] newValues = new TValueType[getCount];
            TmphFloatSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSortDesc<TValueType>
            (TValueType[] values, TmphFloatSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) TmphLog.Error.Throw(TmphLog.TmphExceptionType.IndexOutOfRange);
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (TmphFloatSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSortDesc<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, float> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                    TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphFloatSortIndex));
                    TmphPointer data = pool.Get(count * sizeof(TmphFloatSortIndex));
                    try
                    {
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (TmphFloatSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSortDesc<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, float> getKey, int skipCount, int getCount
            , TmphFloatSortIndex* fixedIndex)
        {
            TmphFloatSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new floatRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            TValueType[] newValues = new TValueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<float> rangeSortDesc
            (this float[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<float> getRangeSortDesc
            (this float[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSortDesc<TValueType>
            (this TValueType[] array, Func<TValueType, float> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<float> rangeSortDesc
            (this float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<float> getRangeSortDesc
            (this float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSortDesc<TValueType>
            (this TValueType[] array, int startIndex, int count, Func<TValueType, float> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<float> pageSortDesc
            (this float[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TValueType[] getPageSortDesc<TValueType>
            (this TValueType[] array, Func<TValueType, float> getKey, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<float> getPageSortDesc
            (this float[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<float> rangeSortDesc
            (this TmphSubArray<float> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<float>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<float> getRangeSortDesc
            (this TmphSubArray<float> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<float>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSortDesc<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, float> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc
                    (array.Array, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<float> pageSortDesc
            (this TmphSubArray<float> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<float>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<float> getPageSortDesc
            (this TmphSubArray<float> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<float>);
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        public unsafe struct TmphDateTimeRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public DateTime* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public DateTime* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(DateTime* startIndex, DateTime* endIndex)
            {
                do
                {
                    DateTime leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    DateTime* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    DateTime value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<DateTime> RangeSort
            (DateTime[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (DateTime* valueFixed = values)
                {
                    new TmphDateTimeRangeSorter
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return TmphSubArray<DateTime>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(TmphSubArray<DateTime>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<DateTime> GetRangeSort
            (DateTime[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                DateTime[] newValues = new DateTime[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(DateTime));
                fixed (DateTime* newValueFixed = newValues, valueFixed = values)
                {
                    new TmphDateTimeRangeSorter
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return TmphSubArray<DateTime>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(TmphSubArray<DateTime>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<DateTime> RangeSort
            (DateTime[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (DateTime* valueFixed = values)
                    {
                        DateTime* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new TmphDateTimeRangeSorter
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return TmphSubArray<DateTime>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(TmphSubArray<DateTime>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<DateTime> GetRangeSort
            (DateTime[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    DateTime[] newValues = new DateTime[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(DateTime), newValues, 0, count * sizeof(DateTime));
                    fixed (DateTime* newValueFixed = newValues, valueFixed = values)
                    {
                        new TmphDateTimeRangeSorter
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return TmphSubArray<DateTime>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(TmphSubArray<DateTime>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        public unsafe struct TmphDateTimeRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public TmphDateTimeSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public TmphDateTimeSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(TmphDateTimeSortIndex* startIndex, TmphDateTimeSortIndex* endIndex)
            {
                do
                {
                    TmphDateTimeSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    TmphDateTimeSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    TmphDateTimeSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    DateTime value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSort<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphDateTimeSortIndex));
                TmphPointer data = pool.Get(values.Length * sizeof(TmphDateTimeSortIndex));
                try
                {
                    return getRangeSort(values, getKey, range.SkipCount, getCount, (TmphDateTimeSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSort<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey, int skipCount, int getCount
            , TmphDateTimeSortIndex* fixedIndex)
        {
            TmphDateTimeSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSort(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSort<TValueType>
            (TValueType[] values, int skipCount, int getCount, TmphDateTimeSortIndex* fixedIndex)
        {
            new TmphDateTimeRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            TValueType[] newValues = new TValueType[getCount];
            TmphDateTimeSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSort<TValueType>
            (TValueType[] values, TmphDateTimeSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) TmphLog.Error.Throw(TmphLog.TmphExceptionType.IndexOutOfRange);
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (TmphDateTimeSortIndex* fixedIndex = indexs) return getRangeSort(values, skipCount, getCount, fixedIndex);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSort<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, DateTime> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                    TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphDateTimeSortIndex));
                    TmphPointer data = pool.Get(count * sizeof(TmphDateTimeSortIndex));
                    try
                    {
                        return getRangeSort
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (TmphDateTimeSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSort<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, DateTime> getKey, int skipCount, int getCount
            , TmphDateTimeSortIndex* fixedIndex)
        {
            TmphDateTimeSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new TmphDateTimeRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            TValueType[] newValues = new TValueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<DateTime> rangeSort
            (this DateTime[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<DateTime> getRangeSort
            (this DateTime[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSort<TValueType>
            (this TValueType[] array, Func<TValueType, DateTime> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<DateTime> rangeSort
            (this DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<DateTime> getRangeSort
            (this DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSort<TValueType>
            (this TValueType[] array, int startIndex, int count, Func<TValueType, DateTime> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<DateTime> pageSort
            (this DateTime[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TValueType[] getPageSort<TValueType>
            (this TValueType[] array, Func<TValueType, DateTime> getKey, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<DateTime> getPageSort
            (this DateTime[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<DateTime> rangeSort
            (this TmphSubArray<DateTime> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<DateTime>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<DateTime> getRangeSort
            (this TmphSubArray<DateTime> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<DateTime>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSort<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, DateTime> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort
                    (array.Array, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<DateTime> pageSort
            (this TmphSubArray<DateTime> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSort(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<DateTime>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<DateTime> getPageSort
            (this TmphSubArray<DateTime> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSort(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<DateTime>);
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        public unsafe struct TmphDateTimeRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public DateTime* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public DateTime* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(DateTime* startIndex, DateTime* endIndex)
            {
                do
                {
                    DateTime leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    DateTime* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    DateTime value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<DateTime> RangeSortDesc
            (DateTime[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (DateTime* valueFixed = values)
                {
                    new TmphDateTimeRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return TmphSubArray<DateTime>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(TmphSubArray<DateTime>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<DateTime> GetRangeSortDesc
            (DateTime[] values, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                DateTime[] newValues = new DateTime[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(DateTime));
                fixed (DateTime* newValueFixed = newValues, valueFixed = values)
                {
                    new TmphDateTimeRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return TmphSubArray<DateTime>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(TmphSubArray<DateTime>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<DateTime> RangeSortDesc
            (DateTime[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (DateTime* valueFixed = values)
                    {
                        DateTime* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new TmphDateTimeRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return TmphSubArray<DateTime>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(TmphSubArray<DateTime>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static TmphSubArray<DateTime> GetRangeSortDesc
            (DateTime[] values, int startIndex, int count, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    DateTime[] newValues = new DateTime[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(DateTime), newValues, 0, count * sizeof(DateTime));
                    fixed (DateTime* newValueFixed = newValues, valueFixed = values)
                    {
                        new TmphDateTimeRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return TmphSubArray<DateTime>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(TmphSubArray<DateTime>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        public unsafe struct TmphDateTimeRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public TmphDateTimeSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public TmphDateTimeSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(TmphDateTimeSortIndex* startIndex, TmphDateTimeSortIndex* endIndex)
            {
                do
                {
                    TmphDateTimeSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    TmphDateTimeSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    TmphDateTimeSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    DateTime value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(values.Length * sizeof(TmphDateTimeSortIndex));
                TmphPointer data = pool.Get(values.Length * sizeof(TmphDateTimeSortIndex));
                try
                {
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, (TmphDateTimeSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSortDesc<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey, int skipCount, int getCount
            , TmphDateTimeSortIndex* fixedIndex)
        {
            TmphDateTimeSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSortDesc<TValueType>
            (TValueType[] values, int skipCount, int getCount, TmphDateTimeSortIndex* fixedIndex)
        {
            new TmphDateTimeRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            TValueType[] newValues = new TValueType[getCount];
            TmphDateTimeSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSortDesc<TValueType>
            (TValueType[] values, TmphDateTimeSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) TmphLog.Error.Throw(TmphLog.TmphExceptionType.IndexOutOfRange);
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (TmphDateTimeSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] GetRangeSortDesc<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, DateTime> getKey, int skipCount, int getCount)
        {
            TmphArray.TmphRange range = new TmphArray.TmphRange(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                TmphArray.TmphRange getRange = new TmphArray.TmphRange(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) TmphLog.Error.Throw(TmphLog.TmphExceptionType.Null);
                    TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(count * sizeof(TmphDateTimeSortIndex));
                    TmphPointer data = pool.Get(count * sizeof(TmphDateTimeSortIndex));
                    try
                    {
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (TmphDateTimeSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static TValueType[] getRangeSortDesc<TValueType>
            (TValueType[] values, int startIndex, int count, Func<TValueType, DateTime> getKey, int skipCount, int getCount
            , TmphDateTimeSortIndex* fixedIndex)
        {
            TmphDateTimeSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new TmphDateTimeRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            TValueType[] newValues = new TValueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace Laurent.Lee.CLB
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class TmphArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<DateTime> rangeSortDesc
            (this DateTime[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<DateTime> getRangeSortDesc
            (this DateTime[] array, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSortDesc<TValueType>
            (this TValueType[] array, Func<TValueType, DateTime> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<DateTime> rangeSortDesc
            (this DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<DateTime> getRangeSortDesc
            (this DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSortDesc<TValueType>
            (this TValueType[] array, int startIndex, int count, Func<TValueType, DateTime> getKey, int skipCount, int getCount)
        {
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<DateTime> pageSortDesc
            (this DateTime[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TValueType[] getPageSortDesc<TValueType>
            (this TValueType[] array, Func<TValueType, DateTime> getKey, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<DateTime> getPageSortDesc
            (this DateTime[] array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.length(), pageSize, currentPage);
            return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class TmphSubArrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<DateTime> rangeSortDesc
            (this TmphSubArray<DateTime> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<DateTime>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TmphSubArray<DateTime> getRangeSortDesc
            (this TmphSubArray<DateTime> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array.Array, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(TmphSubArray<DateTime>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static TValueType[] getRangeSortDesc<TValueType>
            (this TmphSubArray<TValueType> array, Func<TValueType, DateTime> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc
                    (array.Array, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<DateTime> pageSortDesc
            (this TmphSubArray<DateTime> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.RangeSortDesc(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<DateTime>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static TmphSubArray<DateTime> getPageSortDesc
            (this TmphSubArray<DateTime> array, int pageSize, int currentPage)
        {
            TmphArray.TmphPage page = new TmphArray.TmphPage(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return Laurent.Lee.CLB.Algorithm.TmphQuickSort.GetRangeSortDesc(array.Array, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(TmphSubArray<DateTime>);
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 排序索引
    /// </summary>
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
    public struct TmphLongSortIndex
    {
        /// <summary>
        /// 数值
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public long Value;
        /// <summary>
        /// 位置索引
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(sizeof(long))]
        public int Index;
        /// <summary>
        /// 设置排序索引
        /// </summary>
        /// <param name="value">数值</param>
        /// <param name="index">位置索引</param>
        public void Set(long value, int index)
        {
            Value = value;
            Index = index;
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        public unsafe static void Create<TValueType>(TmphLongSortIndex* indexFixed, TValueType[] values, Func<TValueType, long> getValue)
        {
            int index = 0;
            foreach (TValueType value in values) (*indexFixed++).Set(getValue(value), index++);
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void Create<TValueType>(TmphLongSortIndex* indexFixed, TValueType[] values, Func<TValueType, long> getValue, int startIndex, int count)
        {
            for (int endIndex = startIndex + count; startIndex != endIndex; (*indexFixed++).Set(getValue(values[startIndex]), startIndex++)) ;
        }
        /// <summary>
        /// 根据排序索引获取数组
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] Create<TValueType>(TmphLongSortIndex* indexFixed, TValueType[] values, int count)
        {
            TValueType[] newValues = new TValueType[count];
            for (int index = 0; index != count; ++index) newValues[index] = values[(*indexFixed++).Index];
            return newValues;
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 排序索引
    /// </summary>
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
    public struct TmphUintSortIndex
    {
        /// <summary>
        /// 数值
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public uint Value;
        /// <summary>
        /// 位置索引
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(sizeof(uint))]
        public int Index;
        /// <summary>
        /// 设置排序索引
        /// </summary>
        /// <param name="value">数值</param>
        /// <param name="index">位置索引</param>
        public void Set(uint value, int index)
        {
            Value = value;
            Index = index;
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        public unsafe static void Create<TValueType>(TmphUintSortIndex* indexFixed, TValueType[] values, Func<TValueType, uint> getValue)
        {
            int index = 0;
            foreach (TValueType value in values) (*indexFixed++).Set(getValue(value), index++);
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void Create<TValueType>(TmphUintSortIndex* indexFixed, TValueType[] values, Func<TValueType, uint> getValue, int startIndex, int count)
        {
            for (int endIndex = startIndex + count; startIndex != endIndex; (*indexFixed++).Set(getValue(values[startIndex]), startIndex++)) ;
        }
        /// <summary>
        /// 根据排序索引获取数组
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] Create<TValueType>(TmphUintSortIndex* indexFixed, TValueType[] values, int count)
        {
            TValueType[] newValues = new TValueType[count];
            for (int index = 0; index != count; ++index) newValues[index] = values[(*indexFixed++).Index];
            return newValues;
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 排序索引
    /// </summary>
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
    public struct TmphIntSortIndex
    {
        /// <summary>
        /// 数值
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public int Value;
        /// <summary>
        /// 位置索引
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(sizeof(int))]
        public int Index;
        /// <summary>
        /// 设置排序索引
        /// </summary>
        /// <param name="value">数值</param>
        /// <param name="index">位置索引</param>
        public void Set(int value, int index)
        {
            Value = value;
            Index = index;
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        public unsafe static void Create<TValueType>(TmphIntSortIndex* indexFixed, TValueType[] values, Func<TValueType, int> getValue)
        {
            int index = 0;
            foreach (TValueType value in values) (*indexFixed++).Set(getValue(value), index++);
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void Create<TValueType>(TmphIntSortIndex* indexFixed, TValueType[] values, Func<TValueType, int> getValue, int startIndex, int count)
        {
            for (int endIndex = startIndex + count; startIndex != endIndex; (*indexFixed++).Set(getValue(values[startIndex]), startIndex++)) ;
        }
        /// <summary>
        /// 根据排序索引获取数组
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] Create<TValueType>(TmphIntSortIndex* indexFixed, TValueType[] values, int count)
        {
            TValueType[] newValues = new TValueType[count];
            for (int index = 0; index != count; ++index) newValues[index] = values[(*indexFixed++).Index];
            return newValues;
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 排序索引
    /// </summary>
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
    public struct TmphDoubleSortIndex
    {
        /// <summary>
        /// 数值
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public double Value;
        /// <summary>
        /// 位置索引
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(sizeof(double))]
        public int Index;
        /// <summary>
        /// 设置排序索引
        /// </summary>
        /// <param name="value">数值</param>
        /// <param name="index">位置索引</param>
        public void Set(double value, int index)
        {
            Value = value;
            Index = index;
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        public unsafe static void Create<TValueType>(TmphDoubleSortIndex* indexFixed, TValueType[] values, Func<TValueType, double> getValue)
        {
            int index = 0;
            foreach (TValueType value in values) (*indexFixed++).Set(getValue(value), index++);
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void Create<TValueType>(TmphDoubleSortIndex* indexFixed, TValueType[] values, Func<TValueType, double> getValue, int startIndex, int count)
        {
            for (int endIndex = startIndex + count; startIndex != endIndex; (*indexFixed++).Set(getValue(values[startIndex]), startIndex++)) ;
        }
        /// <summary>
        /// 根据排序索引获取数组
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] Create<TValueType>(TmphDoubleSortIndex* indexFixed, TValueType[] values, int count)
        {
            TValueType[] newValues = new TValueType[count];
            for (int index = 0; index != count; ++index) newValues[index] = values[(*indexFixed++).Index];
            return newValues;
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 排序索引
    /// </summary>
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
    public struct TmphFloatSortIndex
    {
        /// <summary>
        /// 数值
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public float Value;
        /// <summary>
        /// 位置索引
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(sizeof(float))]
        public int Index;
        /// <summary>
        /// 设置排序索引
        /// </summary>
        /// <param name="value">数值</param>
        /// <param name="index">位置索引</param>
        public void Set(float value, int index)
        {
            Value = value;
            Index = index;
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        public unsafe static void Create<TValueType>(TmphFloatSortIndex* indexFixed, TValueType[] values, Func<TValueType, float> getValue)
        {
            int index = 0;
            foreach (TValueType value in values) (*indexFixed++).Set(getValue(value), index++);
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        public unsafe static void Create<TValueType>(TmphFloatSortIndex* indexFixed, TValueType[] values, Func<TValueType, float> getValue, int startIndex, int count)
        {
            for (int endIndex = startIndex + count; startIndex != endIndex; (*indexFixed++).Set(getValue(values[startIndex]), startIndex++)) ;
        }
        /// <summary>
        /// 根据排序索引获取数组
        /// </summary>
        /// <typeparam name="TValueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static TValueType[] Create<TValueType>(TmphFloatSortIndex* indexFixed, TValueType[] values, int count)
        {
            TValueType[] newValues = new TValueType[count];
            for (int index = 0; index != count; ++index) newValues[index] = values[(*indexFixed++).Index];
            return newValues;
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<ulong> GetTopDesc(ulong[] values, int count)
        {
            if (values == null) return default(TmphSubArray<ulong>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                else
                {
                    ulong[] newValues = new ulong[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return TmphSubArray<ulong>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<ulong>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<ulong> TopDesc(ulong[] values, int count)
        {
            if (values == null) return default(TmphSubArray<ulong>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                return TmphSubArray<ulong>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<ulong>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TmphSubArray<ulong> getTopDesc(ulong[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            ulong[] newValues = new ulong[length];
            fixed (ulong* newValueFixed = newValues, valueFixed = values)
            {
                ulong* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(ulong));
                //Unsafe.TmphMemory.Copy(readIndex, newValueFixed, length * sizeof(ulong));
                ulong* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                TmphUlongRangeSorterDesc sort
                    = new TmphUlongRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (ulong maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return TmphSubArray<ulong>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static ulong[] getRemoveTopDesc
            (ulong[] values, int count)
        {
            ulong[] newValues = new ulong[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            ulong[] removeValues = new ulong[length];
            fixed (ulong* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(ulong);
                ulong* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(ulong));
                //Unsafe.TmphMemory.Copy(readIndex, removeFixed, length * sizeof(ulong));
                ulong* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                TmphUlongRangeSorterDesc sort
                    = new TmphUlongRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //Unsafe.TmphMemory.Copy(removeFixed, newValueFixed, copyLength);
                for (ulong maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //Unsafe.TmphMemory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //Unsafe.TmphMemory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(ulong));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] GetTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, ulong> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] TopDesc<TValueType>
            (TValueType[] values, Func<TValueType, ulong> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, ulong> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(ulongSortIndex));
            TmphPointer data = pool.Get(length * sizeof(ulongSortIndex));
            try
            {
                return getTopDesc(values, getKey, count, length, (ulongSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, ulong> getKey, int count, int length
            , ulongSortIndex* indexFixed)
        {
            ulongSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            ulongSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            TmphUlongRangeIndexSorterDesc sort
                = new TmphUlongRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (ulong maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                ulong value = getKey(values[index]);
                if (value > maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            TValueType[] newValues = new TValueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getRemoveTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, ulong> getKey, int count)
        {
            TValueType[] newValues = new TValueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(ulongSortIndex));
            TmphPointer data = pool.Get(length * sizeof(ulongSortIndex));
            try
            {
                removeTopDesc(values, getKey, count, newValues, length, (ulongSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, ulong> getKey, int count, TValueType[] newValues, int length
            , ulongSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            ulongSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            ulongSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            TmphUlongRangeIndexSorterDesc sort
                = new TmphUlongRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (ulong maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                ulong value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<long> GetTop(long[] values, int count)
        {
            if (values == null) return default(TmphSubArray<long>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                else
                {
                    long[] newValues = new long[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return TmphSubArray<long>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<long>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<long> Top(long[] values, int count)
        {
            if (values == null) return default(TmphSubArray<long>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                return TmphSubArray<long>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<long>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TmphSubArray<long> getTop(long[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            long[] newValues = new long[length];
            fixed (long* newValueFixed = newValues, valueFixed = values)
            {
                long* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(long));
                //Unsafe.TmphMemory.Copy(readIndex, newValueFixed, length * sizeof(long));
                long* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                longRangeSorter sort
                    = new longRangeSorter
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (long maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return TmphSubArray<long>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static long[] getRemoveTop
            (long[] values, int count)
        {
            long[] newValues = new long[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            long[] removeValues = new long[length];
            fixed (long* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(long);
                long* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(long));
                //Unsafe.TmphMemory.Copy(readIndex, removeFixed, length * sizeof(long));
                long* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                longRangeSorter sort
                    = new longRangeSorter
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //Unsafe.TmphMemory.Copy(removeFixed, newValueFixed, copyLength);
                for (long maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //Unsafe.TmphMemory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //Unsafe.TmphMemory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(long));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] GetTop<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.copy();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] Top<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.notNull();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTop<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphLongSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphLongSortIndex));
            try
            {
                return getTop(values, getKey, count, length, (TmphLongSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTop<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey, int count, int length
            , TmphLongSortIndex* indexFixed)
        {
            TmphLongSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            TmphLongSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            longRangeIndexSorter sort
                = new longRangeIndexSorter
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (long maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                long value = getKey(values[index]);
                if (value < maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            TValueType[] newValues = new TValueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getRemoveTop<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey, int count)
        {
            TValueType[] newValues = new TValueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphLongSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphLongSortIndex));
            try
            {
                removeTop(values, getKey, count, newValues, length, (TmphLongSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTop<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey, int count, TValueType[] newValues, int length
            , TmphLongSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            TmphLongSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            TmphLongSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            longRangeIndexSorter sort
                = new longRangeIndexSorter
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (long maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                long value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<long> GetTopDesc(long[] values, int count)
        {
            if (values == null) return default(TmphSubArray<long>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                else
                {
                    long[] newValues = new long[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return TmphSubArray<long>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<long>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<long> TopDesc(long[] values, int count)
        {
            if (values == null) return default(TmphSubArray<long>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                return TmphSubArray<long>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<long>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TmphSubArray<long> getTopDesc(long[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            long[] newValues = new long[length];
            fixed (long* newValueFixed = newValues, valueFixed = values)
            {
                long* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(long));
                //Unsafe.TmphMemory.Copy(readIndex, newValueFixed, length * sizeof(long));
                long* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                longRangeSorterDesc sort
                    = new longRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (long maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return TmphSubArray<long>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static long[] getRemoveTopDesc
            (long[] values, int count)
        {
            long[] newValues = new long[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            long[] removeValues = new long[length];
            fixed (long* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(long);
                long* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(long));
                //Unsafe.TmphMemory.Copy(readIndex, removeFixed, length * sizeof(long));
                long* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                longRangeSorterDesc sort
                    = new longRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //Unsafe.TmphMemory.Copy(removeFixed, newValueFixed, copyLength);
                for (long maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //Unsafe.TmphMemory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //Unsafe.TmphMemory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(long));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] GetTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] TopDesc<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphLongSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphLongSortIndex));
            try
            {
                return getTopDesc(values, getKey, count, length, (TmphLongSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey, int count, int length
            , TmphLongSortIndex* indexFixed)
        {
            TmphLongSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            TmphLongSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            longRangeIndexSorterDesc sort
                = new longRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (long maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                long value = getKey(values[index]);
                if (value > maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            TValueType[] newValues = new TValueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getRemoveTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey, int count)
        {
            TValueType[] newValues = new TValueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphLongSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphLongSortIndex));
            try
            {
                removeTopDesc(values, getKey, count, newValues, length, (TmphLongSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, long> getKey, int count, TValueType[] newValues, int length
            , TmphLongSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            TmphLongSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            TmphLongSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            longRangeIndexSorterDesc sort
                = new longRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (long maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                long value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<uint> GetTop(uint[] values, int count)
        {
            if (values == null) return default(TmphSubArray<uint>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                else
                {
                    uint[] newValues = new uint[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return TmphSubArray<uint>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<uint>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<uint> Top(uint[] values, int count)
        {
            if (values == null) return default(TmphSubArray<uint>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                return TmphSubArray<uint>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<uint>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TmphSubArray<uint> getTop(uint[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            uint[] newValues = new uint[length];
            fixed (uint* newValueFixed = newValues, valueFixed = values)
            {
                uint* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(uint));
                //Unsafe.TmphMemory.Copy(readIndex, newValueFixed, length * sizeof(uint));
                uint* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                uintRangeSorter sort
                    = new uintRangeSorter
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (uint maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return TmphSubArray<uint>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static uint[] getRemoveTop
            (uint[] values, int count)
        {
            uint[] newValues = new uint[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            uint[] removeValues = new uint[length];
            fixed (uint* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(uint);
                uint* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(uint));
                //Unsafe.TmphMemory.Copy(readIndex, removeFixed, length * sizeof(uint));
                uint* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                uintRangeSorter sort
                    = new uintRangeSorter
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //Unsafe.TmphMemory.Copy(removeFixed, newValueFixed, copyLength);
                for (uint maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //Unsafe.TmphMemory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //Unsafe.TmphMemory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(uint));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] GetTop<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.copy();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] Top<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.notNull();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTop<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphUintSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphUintSortIndex));
            try
            {
                return getTop(values, getKey, count, length, (TmphUintSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTop<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey, int count, int length
            , TmphUintSortIndex* indexFixed)
        {
            TmphUintSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            TmphUintSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            uintRangeIndexSorter sort
                = new uintRangeIndexSorter
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (uint maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                uint value = getKey(values[index]);
                if (value < maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            TValueType[] newValues = new TValueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getRemoveTop<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey, int count)
        {
            TValueType[] newValues = new TValueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphUintSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphUintSortIndex));
            try
            {
                removeTop(values, getKey, count, newValues, length, (TmphUintSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTop<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey, int count, TValueType[] newValues, int length
            , TmphUintSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            TmphUintSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            TmphUintSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            uintRangeIndexSorter sort
                = new uintRangeIndexSorter
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (uint maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                uint value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<uint> GetTopDesc(uint[] values, int count)
        {
            if (values == null) return default(TmphSubArray<uint>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                else
                {
                    uint[] newValues = new uint[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return TmphSubArray<uint>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<uint>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<uint> TopDesc(uint[] values, int count)
        {
            if (values == null) return default(TmphSubArray<uint>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                return TmphSubArray<uint>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<uint>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TmphSubArray<uint> getTopDesc(uint[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            uint[] newValues = new uint[length];
            fixed (uint* newValueFixed = newValues, valueFixed = values)
            {
                uint* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(uint));
                //Unsafe.TmphMemory.Copy(readIndex, newValueFixed, length * sizeof(uint));
                uint* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                uintRangeSorterDesc sort
                    = new uintRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (uint maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return TmphSubArray<uint>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static uint[] getRemoveTopDesc
            (uint[] values, int count)
        {
            uint[] newValues = new uint[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            uint[] removeValues = new uint[length];
            fixed (uint* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(uint);
                uint* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(uint));
                //Unsafe.TmphMemory.Copy(readIndex, removeFixed, length * sizeof(uint));
                uint* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                uintRangeSorterDesc sort
                    = new uintRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //Unsafe.TmphMemory.Copy(removeFixed, newValueFixed, copyLength);
                for (uint maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //Unsafe.TmphMemory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //Unsafe.TmphMemory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(uint));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] GetTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] TopDesc<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphUintSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphUintSortIndex));
            try
            {
                return getTopDesc(values, getKey, count, length, (TmphUintSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey, int count, int length
            , TmphUintSortIndex* indexFixed)
        {
            TmphUintSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            TmphUintSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            uintRangeIndexSorterDesc sort
                = new uintRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (uint maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                uint value = getKey(values[index]);
                if (value > maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            TValueType[] newValues = new TValueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getRemoveTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey, int count)
        {
            TValueType[] newValues = new TValueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphUintSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphUintSortIndex));
            try
            {
                removeTopDesc(values, getKey, count, newValues, length, (TmphUintSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, uint> getKey, int count, TValueType[] newValues, int length
            , TmphUintSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            TmphUintSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            TmphUintSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            uintRangeIndexSorterDesc sort
                = new uintRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (uint maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                uint value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<int> GetTop(int[] values, int count)
        {
            if (values == null) return default(TmphSubArray<int>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                else
                {
                    int[] newValues = new int[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return TmphSubArray<int>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<int>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<int> Top(int[] values, int count)
        {
            if (values == null) return default(TmphSubArray<int>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                return TmphSubArray<int>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<int>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TmphSubArray<int> getTop(int[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            int[] newValues = new int[length];
            fixed (int* newValueFixed = newValues, valueFixed = values)
            {
                int* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(int));
                //Unsafe.TmphMemory.Copy(readIndex, newValueFixed, length * sizeof(int));
                int* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                intRangeSorter sort
                    = new intRangeSorter
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (int maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return TmphSubArray<int>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static int[] getRemoveTop
            (int[] values, int count)
        {
            int[] newValues = new int[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            int[] removeValues = new int[length];
            fixed (int* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(int);
                int* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(int));
                //Unsafe.TmphMemory.Copy(readIndex, removeFixed, length * sizeof(int));
                int* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                intRangeSorter sort
                    = new intRangeSorter
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //Unsafe.TmphMemory.Copy(removeFixed, newValueFixed, copyLength);
                for (int maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //Unsafe.TmphMemory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //Unsafe.TmphMemory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(int));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] GetTop<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.copy();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] Top<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.notNull();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTop<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphIntSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphIntSortIndex));
            try
            {
                return getTop(values, getKey, count, length, (TmphIntSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTop<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey, int count, int length
            , TmphIntSortIndex* indexFixed)
        {
            TmphIntSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            TmphIntSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            intRangeIndexSorter sort
                = new intRangeIndexSorter
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (int maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                int value = getKey(values[index]);
                if (value < maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            TValueType[] newValues = new TValueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getRemoveTop<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey, int count)
        {
            TValueType[] newValues = new TValueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphIntSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphIntSortIndex));
            try
            {
                removeTop(values, getKey, count, newValues, length, (TmphIntSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTop<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey, int count, TValueType[] newValues, int length
            , TmphIntSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            TmphIntSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            TmphIntSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            intRangeIndexSorter sort
                = new intRangeIndexSorter
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (int maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                int value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<int> GetTopDesc(int[] values, int count)
        {
            if (values == null) return default(TmphSubArray<int>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                else
                {
                    int[] newValues = new int[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return TmphSubArray<int>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<int>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<int> TopDesc(int[] values, int count)
        {
            if (values == null) return default(TmphSubArray<int>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                return TmphSubArray<int>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<int>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TmphSubArray<int> getTopDesc(int[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            int[] newValues = new int[length];
            fixed (int* newValueFixed = newValues, valueFixed = values)
            {
                int* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(int));
                //Unsafe.TmphMemory.Copy(readIndex, newValueFixed, length * sizeof(int));
                int* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                intRangeSorterDesc sort
                    = new intRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (int maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return TmphSubArray<int>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static int[] getRemoveTopDesc
            (int[] values, int count)
        {
            int[] newValues = new int[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            int[] removeValues = new int[length];
            fixed (int* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(int);
                int* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(int));
                //Unsafe.TmphMemory.Copy(readIndex, removeFixed, length * sizeof(int));
                int* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                intRangeSorterDesc sort
                    = new intRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //Unsafe.TmphMemory.Copy(removeFixed, newValueFixed, copyLength);
                for (int maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //Unsafe.TmphMemory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //Unsafe.TmphMemory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(int));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] GetTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] TopDesc<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphIntSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphIntSortIndex));
            try
            {
                return getTopDesc(values, getKey, count, length, (TmphIntSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey, int count, int length
            , TmphIntSortIndex* indexFixed)
        {
            TmphIntSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            TmphIntSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            intRangeIndexSorterDesc sort
                = new intRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (int maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                int value = getKey(values[index]);
                if (value > maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            TValueType[] newValues = new TValueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getRemoveTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey, int count)
        {
            TValueType[] newValues = new TValueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphIntSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphIntSortIndex));
            try
            {
                removeTopDesc(values, getKey, count, newValues, length, (TmphIntSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, int> getKey, int count, TValueType[] newValues, int length
            , TmphIntSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            TmphIntSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            TmphIntSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            intRangeIndexSorterDesc sort
                = new intRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (int maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                int value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<double> GetTop(double[] values, int count)
        {
            if (values == null) return default(TmphSubArray<double>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                else
                {
                    double[] newValues = new double[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return TmphSubArray<double>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<double>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<double> Top(double[] values, int count)
        {
            if (values == null) return default(TmphSubArray<double>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                return TmphSubArray<double>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<double>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TmphSubArray<double> getTop(double[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            double[] newValues = new double[length];
            fixed (double* newValueFixed = newValues, valueFixed = values)
            {
                double* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(double));
                //Unsafe.TmphMemory.Copy(readIndex, newValueFixed, length * sizeof(double));
                double* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                doubleRangeSorter sort
                    = new doubleRangeSorter
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (double maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return TmphSubArray<double>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static double[] getRemoveTop
            (double[] values, int count)
        {
            double[] newValues = new double[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            double[] removeValues = new double[length];
            fixed (double* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(double);
                double* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(double));
                //Unsafe.TmphMemory.Copy(readIndex, removeFixed, length * sizeof(double));
                double* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                doubleRangeSorter sort
                    = new doubleRangeSorter
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //Unsafe.TmphMemory.Copy(removeFixed, newValueFixed, copyLength);
                for (double maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //Unsafe.TmphMemory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //Unsafe.TmphMemory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(double));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] GetTop<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.copy();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] Top<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.notNull();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTop<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphDoubleSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphDoubleSortIndex));
            try
            {
                return getTop(values, getKey, count, length, (TmphDoubleSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTop<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey, int count, int length
            , TmphDoubleSortIndex* indexFixed)
        {
            TmphDoubleSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            TmphDoubleSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            TmphDoubleRangeIndexSorter sort
                = new TmphDoubleRangeIndexSorter
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (double maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                double value = getKey(values[index]);
                if (value < maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            TValueType[] newValues = new TValueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getRemoveTop<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey, int count)
        {
            TValueType[] newValues = new TValueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphDoubleSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphDoubleSortIndex));
            try
            {
                removeTop(values, getKey, count, newValues, length, (TmphDoubleSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTop<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey, int count, TValueType[] newValues, int length
            , TmphDoubleSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            TmphDoubleSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            TmphDoubleSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            TmphDoubleRangeIndexSorter sort
                = new TmphDoubleRangeIndexSorter
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (double maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                double value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<double> GetTopDesc(double[] values, int count)
        {
            if (values == null) return default(TmphSubArray<double>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                else
                {
                    double[] newValues = new double[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return TmphSubArray<double>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<double>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<double> TopDesc(double[] values, int count)
        {
            if (values == null) return default(TmphSubArray<double>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                return TmphSubArray<double>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<double>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TmphSubArray<double> getTopDesc(double[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            double[] newValues = new double[length];
            fixed (double* newValueFixed = newValues, valueFixed = values)
            {
                double* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(double));
                //Unsafe.TmphMemory.Copy(readIndex, newValueFixed, length * sizeof(double));
                double* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                doubleRangeSorterDesc sort
                    = new doubleRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (double maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return TmphSubArray<double>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static double[] getRemoveTopDesc
            (double[] values, int count)
        {
            double[] newValues = new double[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            double[] removeValues = new double[length];
            fixed (double* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(double);
                double* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(double));
                //Unsafe.TmphMemory.Copy(readIndex, removeFixed, length * sizeof(double));
                double* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                doubleRangeSorterDesc sort
                    = new doubleRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //Unsafe.TmphMemory.Copy(removeFixed, newValueFixed, copyLength);
                for (double maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //Unsafe.TmphMemory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //Unsafe.TmphMemory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(double));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] GetTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] TopDesc<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphDoubleSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphDoubleSortIndex));
            try
            {
                return getTopDesc(values, getKey, count, length, (TmphDoubleSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey, int count, int length
            , TmphDoubleSortIndex* indexFixed)
        {
            TmphDoubleSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            TmphDoubleSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            doubleRangeIndexSorterDesc sort
                = new doubleRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (double maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                double value = getKey(values[index]);
                if (value > maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            TValueType[] newValues = new TValueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getRemoveTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey, int count)
        {
            TValueType[] newValues = new TValueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphDoubleSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphDoubleSortIndex));
            try
            {
                removeTopDesc(values, getKey, count, newValues, length, (TmphDoubleSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, double> getKey, int count, TValueType[] newValues, int length
            , TmphDoubleSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            TmphDoubleSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            TmphDoubleSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            doubleRangeIndexSorterDesc sort
                = new doubleRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (double maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                double value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<float> GetTop(float[] values, int count)
        {
            if (values == null) return default(TmphSubArray<float>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                else
                {
                    float[] newValues = new float[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return TmphSubArray<float>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<float>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<float> Top(float[] values, int count)
        {
            if (values == null) return default(TmphSubArray<float>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                return TmphSubArray<float>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<float>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TmphSubArray<float> getTop(float[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            float[] newValues = new float[length];
            fixed (float* newValueFixed = newValues, valueFixed = values)
            {
                float* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(float));
                //Unsafe.TmphMemory.Copy(readIndex, newValueFixed, length * sizeof(float));
                float* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                floatRangeSorter sort
                    = new floatRangeSorter
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (float maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return TmphSubArray<float>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static float[] getRemoveTop
            (float[] values, int count)
        {
            float[] newValues = new float[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            float[] removeValues = new float[length];
            fixed (float* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(float);
                float* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(float));
                //Unsafe.TmphMemory.Copy(readIndex, removeFixed, length * sizeof(float));
                float* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                floatRangeSorter sort
                    = new floatRangeSorter
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //Unsafe.TmphMemory.Copy(removeFixed, newValueFixed, copyLength);
                for (float maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //Unsafe.TmphMemory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //Unsafe.TmphMemory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(float));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] GetTop<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.copy();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] Top<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.notNull();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTop<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphFloatSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphFloatSortIndex));
            try
            {
                return getTop(values, getKey, count, length, (TmphFloatSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTop<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey, int count, int length
            , TmphFloatSortIndex* indexFixed)
        {
            TmphFloatSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            TmphFloatSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            floatRangeIndexSorter sort
                = new floatRangeIndexSorter
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (float maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                float value = getKey(values[index]);
                if (value < maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            TValueType[] newValues = new TValueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getRemoveTop<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey, int count)
        {
            TValueType[] newValues = new TValueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphFloatSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphFloatSortIndex));
            try
            {
                removeTop(values, getKey, count, newValues, length, (TmphFloatSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTop<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey, int count, TValueType[] newValues, int length
            , TmphFloatSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            TmphFloatSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            TmphFloatSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            floatRangeIndexSorter sort
                = new floatRangeIndexSorter
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (float maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                float value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<float> GetTopDesc(float[] values, int count)
        {
            if (values == null) return default(TmphSubArray<float>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                else
                {
                    float[] newValues = new float[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return TmphSubArray<float>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<float>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<float> TopDesc(float[] values, int count)
        {
            if (values == null) return default(TmphSubArray<float>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                return TmphSubArray<float>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<float>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TmphSubArray<float> getTopDesc(float[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            float[] newValues = new float[length];
            fixed (float* newValueFixed = newValues, valueFixed = values)
            {
                float* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(float));
                //Unsafe.TmphMemory.Copy(readIndex, newValueFixed, length * sizeof(float));
                float* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                floatRangeSorterDesc sort
                    = new floatRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (float maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return TmphSubArray<float>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static float[] getRemoveTopDesc
            (float[] values, int count)
        {
            float[] newValues = new float[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            float[] removeValues = new float[length];
            fixed (float* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(float);
                float* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(float));
                //Unsafe.TmphMemory.Copy(readIndex, removeFixed, length * sizeof(float));
                float* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                floatRangeSorterDesc sort
                    = new floatRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //Unsafe.TmphMemory.Copy(removeFixed, newValueFixed, copyLength);
                for (float maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //Unsafe.TmphMemory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //Unsafe.TmphMemory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(float));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] GetTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] TopDesc<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphFloatSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphFloatSortIndex));
            try
            {
                return getTopDesc(values, getKey, count, length, (TmphFloatSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey, int count, int length
            , TmphFloatSortIndex* indexFixed)
        {
            TmphFloatSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            TmphFloatSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            floatRangeIndexSorterDesc sort
                = new floatRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (float maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                float value = getKey(values[index]);
                if (value > maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            TValueType[] newValues = new TValueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getRemoveTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey, int count)
        {
            TValueType[] newValues = new TValueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphFloatSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphFloatSortIndex));
            try
            {
                removeTopDesc(values, getKey, count, newValues, length, (TmphFloatSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, float> getKey, int count, TValueType[] newValues, int length
            , TmphFloatSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            TmphFloatSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            TmphFloatSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            floatRangeIndexSorterDesc sort
                = new floatRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (float maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                float value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<DateTime> GetTop(DateTime[] values, int count)
        {
            if (values == null) return default(TmphSubArray<DateTime>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                else
                {
                    DateTime[] newValues = new DateTime[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return TmphSubArray<DateTime>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<DateTime>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<DateTime> Top(DateTime[] values, int count)
        {
            if (values == null) return default(TmphSubArray<DateTime>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                return TmphSubArray<DateTime>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<DateTime>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TmphSubArray<DateTime> getTop(DateTime[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            DateTime[] newValues = new DateTime[length];
            fixed (DateTime* newValueFixed = newValues, valueFixed = values)
            {
                DateTime* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(DateTime));
                //Unsafe.TmphMemory.Copy(readIndex, newValueFixed, length * sizeof(DateTime));
                DateTime* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                TmphDateTimeRangeSorter sort
                    = new TmphDateTimeRangeSorter
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (DateTime maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return TmphSubArray<DateTime>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static DateTime[] getRemoveTop
            (DateTime[] values, int count)
        {
            DateTime[] newValues = new DateTime[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            DateTime[] removeValues = new DateTime[length];
            fixed (DateTime* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(DateTime);
                DateTime* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(DateTime));
                //Unsafe.TmphMemory.Copy(readIndex, removeFixed, length * sizeof(DateTime));
                DateTime* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                TmphDateTimeRangeSorter sort
                    = new TmphDateTimeRangeSorter
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //Unsafe.TmphMemory.Copy(removeFixed, newValueFixed, copyLength);
                for (DateTime maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //Unsafe.TmphMemory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //Unsafe.TmphMemory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(DateTime));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] GetTop<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.copy();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] Top<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.notNull();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTop<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphDateTimeSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphDateTimeSortIndex));
            try
            {
                return getTop(values, getKey, count, length, (TmphDateTimeSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTop<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey, int count, int length
            , TmphDateTimeSortIndex* indexFixed)
        {
            TmphDateTimeSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            TmphDateTimeSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            TmphDateTimeRangeIndexSorter sort
                = new TmphDateTimeRangeIndexSorter
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (DateTime maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                DateTime value = getKey(values[index]);
                if (value < maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            TValueType[] newValues = new TValueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getRemoveTop<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey, int count)
        {
            TValueType[] newValues = new TValueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphDateTimeSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphDateTimeSortIndex));
            try
            {
                removeTop(values, getKey, count, newValues, length, (TmphDateTimeSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTop<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey, int count, TValueType[] newValues, int length
            , TmphDateTimeSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            TmphDateTimeSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            TmphDateTimeSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            TmphDateTimeRangeIndexSorter sort
                = new TmphDateTimeRangeIndexSorter
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (DateTime maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                DateTime value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace Laurent.Lee.CLB.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    public static partial class TmphQuickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<DateTime> GetTopDesc(DateTime[] values, int count)
        {
            if (values == null) return default(TmphSubArray<DateTime>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                else
                {
                    DateTime[] newValues = new DateTime[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return TmphSubArray<DateTime>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<DateTime>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static TmphSubArray<DateTime> TopDesc(DateTime[] values, int count)
        {
            if (values == null) return default(TmphSubArray<DateTime>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                return TmphSubArray<DateTime>.Unsafe(values, 0, values.Length);
            }
            return default(TmphSubArray<DateTime>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TmphSubArray<DateTime> getTopDesc(DateTime[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            DateTime[] newValues = new DateTime[length];
            fixed (DateTime* newValueFixed = newValues, valueFixed = values)
            {
                DateTime* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(DateTime));
                //Unsafe.TmphMemory.Copy(readIndex, newValueFixed, length * sizeof(DateTime));
                DateTime* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                TmphDateTimeRangeSorterDesc sort
                    = new TmphDateTimeRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (DateTime maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return TmphSubArray<DateTime>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static DateTime[] getRemoveTopDesc
            (DateTime[] values, int count)
        {
            DateTime[] newValues = new DateTime[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            DateTime[] removeValues = new DateTime[length];
            fixed (DateTime* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(DateTime);
                DateTime* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(DateTime));
                //Unsafe.TmphMemory.Copy(readIndex, removeFixed, length * sizeof(DateTime));
                DateTime* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                TmphDateTimeRangeSorterDesc sort
                    = new TmphDateTimeRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //Unsafe.TmphMemory.Copy(removeFixed, newValueFixed, copyLength);
                for (DateTime maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //Unsafe.TmphMemory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //Unsafe.TmphMemory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(DateTime));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] GetTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static TValueType[] TopDesc<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return TmphNullValue<TValueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphDateTimeSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphDateTimeSortIndex));
            try
            {
                return getTopDesc(values, getKey, count, length, (TmphDateTimeSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey, int count, int length
            , TmphDateTimeSortIndex* indexFixed)
        {
            TmphDateTimeSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            TmphDateTimeSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            TmphDateTimeRangeIndexSorterDesc sort
                = new TmphDateTimeRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (DateTime maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                DateTime value = getKey(values[index]);
                if (value > maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            TValueType[] newValues = new TValueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static TValueType[] getRemoveTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey, int count)
        {
            TValueType[] newValues = new TValueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)TmphNumber.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            TmphUnmanagedPool pool = CLB.TmphUnmanagedPool.GetDefaultPool(length * sizeof(TmphDateTimeSortIndex));
            TmphPointer data = pool.Get(length * sizeof(TmphDateTimeSortIndex));
            try
            {
                removeTopDesc(values, getKey, count, newValues, length, (TmphDateTimeSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="TValueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        private unsafe static void removeTopDesc<TValueType>
            (TValueType[] values, Func<TValueType, DateTime> getKey, int count, TValueType[] newValues, int length
            , TmphDateTimeSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            TmphDateTimeSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            TmphDateTimeSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            TmphDateTimeRangeIndexSorterDesc sort
                = new TmphDateTimeRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (DateTime maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                DateTime value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}